1
00:00:00,000 --> 00:00:04,440
Вы скажете: "Брэнт, это отличный заголовок, но...

2
00:00:04,540 --> 00:00:07,400
у меня нет 17 машин.

3
00:00:08,680 --> 00:00:10,940
Ну и что мне делать?

4
00:00:11,220 --> 00:00:17,640
Ладно. Кто тут новенький? Я новенький. Поднимите руки? Спасибо за честность

5
00:00:18,760 --> 00:00:22,360
Это поможет вам начать с весёлой части

6
00:00:22,440 --> 00:00:26,580
а всю боль мы оставим на потом.

7
00:00:26,660 --> 00:00:28,580
 Я хочу помочь новичкам

8
00:00:29,220 --> 00:00:33,300
Кого-нибудь заказчик просил установить мощный двигатель в минивэн?

9
00:00:33,300 --> 00:00:39,520
Во. Он познал боль. Я хочу помочь тебе попасть домой пораньше, чтобы жена и дети смогли увидеть как ты улыбаешься

10
00:00:39,680 --> 00:00:46,120
 Ну и еще это для простых обывателей. Кто помнит скандал с Volkswagen? Дизельгейт? Кто-нибудь помнит?

11
00:00:46,840 --> 00:00:55,380
Это поможет вам получить данные из машины, не тратя кучу времени на исследование, как получить из неё нужную информацию. Компьютер просто пикает, и вот то, что вам нужно

12
00:00:55,380 --> 00:00:55,400
И тут вы говорите: "Похоже, моя машина делает не то, что говорил продавец...
Это поможет вам получить данные из машины, не тратя кучу времени на исследование, как получить из неё нужную информацию. Компьютер просто пикает, и вот то, что вам нужно

13
00:00:55,400 --> 00:00:59,600
И тут вы говорите: "Похоже, моя машина делает не то, что говорил продавец...

14
00:00:59,600 --> 00:01:04,000
... У меня же должен был быть чистый дизель, а это вовсе не выглядит чисто"

15
00:01:04,000 --> 00:01:13,660
Этот код именно для этого. Я понимаю, ни у кого нет 17 машин, чтобы использовать мой код на каждой из них. Но  задача именно в универсальности

16
00:01:13,820 --> 00:01:21,660
 И еще один плюс: код применим не только к автомобилям. Я к этому вернусь позже

17
00:01:21,780 --> 00:01:29,000
SCADA системы, всё, что угодно, где один компьютер отсылает другому пакеты фиксированной длины и где нету никаких метаданных

18
00:01:29,000 --> 00:01:36,520
Эта штука поможет вам, какой бы ни была ваша цель. Это не только про тачки

19
00:01:36,620 --> 00:01:42,500
Дисклэймер: я служу в армии. Всё, что я говорю, моя личное мнение.

20
00:01:42,500 --> 00:01:46,700
Оно не выражает позицию Министерства Обороны, Армии США, ВВС США

21
00:01:47,040 --> 00:01:53,920
 или кого-то еще кроме меня. Если я говорю глупость, это моя вина, не Америки.

22
00:01:54,940 --> 00:02:02,760
Это будет серьёзное упрощение, но помните, я новичёк, пожалуйста, не издевайтесь надо мной после этого.

23
00:02:02,760 --> 00:02:05,960
Давайте разделим все сети на две вкуса

24
00:02:05,960 --> 00:02:09,800
Первый, ванильный: General Use Network

25
00:02:09,960 --> 00:02:17,360
Основная цель: быть гибкой. Например, интернет. Я хочу добавлять/удалять хосты и соединения

26
00:02:17,420 --> 00:02:22,840
Меня не волнует, что происходит в ней. Я просто хочу подключиться и взаимодействовать с чем-то в ней

27
00:02:22,840 --> 00:02:28,880
Но тут в жертву приносятся гарантии. У вас нет гарантий, что сообщение дойдёт до адресата

28
00:02:28,880 --> 00:02:32,580
Нет гарантий, *когда* оно до него дойдёт. Возможно, придётся отправить его еще раз

29
00:02:32,580 --> 00:02:39,520
Возможно, придётся сказать: "Это мой IP. Какой у тебя?" И всё это заворачивается в кучу метаданных

30
00:02:39,520 --> 00:02:47,060
И нужно это для того, чтобы быть уверенным, что сообщение будет доставлено в целости и сохранности. Поэтому в сетях общего пользования много метаданных

31
00:02:47,060 --> 00:02:56,920
С другой стороны спектра всё ровно наоборот. Мне не нужна гибкость. Я хочу гарантий. Когда я жму тормоз, я хочу, чтобы машина останавливалась.

32
00:02:56,920 --> 00:03:02,900
Я не хочу, чтобы сообщение о нажатии на педаль пересылалось заново. Я хочу, чтобы оно работало с первого раза и вовремя

33
00:03:02,920 --> 00:03:06,860
Поэтому мне нужна гарантия, что сообщение будет доставлено и что это произойдёт вовремя

34
00:03:06,860 --> 00:03:11,400
Эта сеть называется Control Network. В них вы лишаетесь гибкости

35
00:03:11,400 --> 00:03:19,260
 Вы не добавите еще одно колесо к своей машине. Кто здесь хочеть добавить еще колесо? Есть психи?

36
00:03:19,260 --> 00:03:24,820
Здесь вы об этом не беспокоитесь. Тут важна гарантия доставки и времени

37
00:03:24,820 --> 00:03:28,600
Код, о котором я расскажу фокусируется именно на Control Networks

38
00:03:28,600 --> 00:03:40,620
Из-за этого его применение ограничено. В General Use Network у вас есть сочные метаданные. Заглянув в них, вы увидите кучу тегов. Вероятно, вам даже не нужно ковыряться в нагрузке [payload]

39
00:03:40,620 --> 00:03:44,300
Достаточно лишь взглянуть на метаданные, но их нет в Control Network.

40
00:03:44,340 --> 00:03:51,120
 В тачке только биты: 64 бита... еще 64 бита. Там вообще нет метаданных

41
00:03:51,180 --> 00:03:59,180
Много народу умнее меня уже сделало кучу всего, что позволит вам поиграться с General Use Network

42
00:03:59,180 --> 00:04:06,720
По крайней мере с тем, что Брент ими называет. VoIP, внутренние сети, смартфоны, IoT

43
00:04:06,720 --> 00:04:16,780
В дополнение к исследованиям, есть Wireshark, есть snork. Масса штук, которые можно подключить к чему-то опенсоурсному или широко используемому

44
00:04:16,780 --> 00:04:20,780
 Есть масса исследований, которые проводят ядерные интеллектулы, пытаясь решить какую-либо задачу

45
00:04:20,780 --> 00:04:33,620
В частости последние четыре статьи. Кажется, их можно скачать с сервера DefCon. Если вы хотите упороться и полистать, на мой взгляд в последних четырёх статьях ребята провели отличную работу в автоматизации реверс-инжиниринга General Use Network

46
00:04:33,660 --> 00:04:41,560
 Но я хочу поиграться с тачками! Или с медоборудованием. Или с самолётами. Или с поездами. Или еще с чем-то

47
00:04:41,560 --> 00:04:49,240
Но нет ничего, что вам бы помогло в этом... Точнее не было. Давайте взглянет, на что оно способно

48
00:04:49,240 --> 00:04:57,260
Я хочу получить кучу сырых данных из Control Network. Я жму на кнопку. Бум! Оно выплёвывает полезную и актуальную информацию

49
00:04:57,260 --> 00:05:03,960
Возможно, где-то я ошибусь на бит или два, но в целом достоверность порядка 99%. Короче, я просто хочу волшебства

50
00:05:04,080 --> 00:05:10,140
Итак, что же делает код. Я выложил его на github, об этом я расскажу чуть позже

51
00:05:10,140 --> 00:05:21,480
Брент, что ты творишь на этом слайде? Что всё это значит? Выглядит как таблица окулиста (eye chart). В армии мы называем это nye chart. "Зачем ты это показываешь? Я это не заслуживаю!"

52
00:05:21,480 --> 00:05:27,640
Клёвый момент в том, что, когда вы зайдёте на github, не пугайтесь. Единственное, что вам нужно это препроцессинг

53
00:05:27,640 --> 00:05:39,460
Все элементы слабо связаны, поэтому вы можете легко взять другой протокол... Я уже это делал, кстати... Взять совершенно другой протокол, не трогая примерно 90% кода, и эта штука зареверсит его автоматически

54
00:05:39,480 --> 00:05:44,400
Поэтому она применима не только к автомобилям. Если вы заснифали данные с медицинского оборудования

55
00:05:44,460 --> 00:05:58,760
И выполняется условие, что передаваемые данные всегда имеют фиксированный размер: 2 байта, 64 бита и тд. Этот софт скорее всего будет вам полезен

56
00:05:58,900 --> 00:06:12,200
 Чуть позже я покажу пример использования. На самом деле три примера. Мы подготовили всё и подключили мой ноутбук. Так что будет три демки, чтобы удовлетворить всех, кто смотрит эту презентацию

57
00:06:12,320 --> 00:06:21,900
Демо состоит из двух частей. Это показывает как быстро работает софт. К примеру, если вы подключитесь к ARM чипу

58
00:06:22,000 --> 00:06:26,620
или какой-нибудь SoC. И он будет работать эффективно. Очень эффективно

59
00:06:26,620 --> 00:06:30,420
Ну и вторая часть: как реверсить сам протокол

60
00:06:30,420 --> 00:06:39,660
В частности на слайдах я покажу *ментальный подход* к изучению и ковырянию в данных, чтобы достать конкретную информацию

61
00:06:39,660 --> 00:06:46,320
Ну и еще куча всего лежит в репозитории. Опять же, не беспокойтесь об этом. Вам нужно разобраться только с первой часть

62
00:06:46,420 --> 00:06:53,780
Ладно, давайте взглянем на логику. Забудем про код и разберёмся в логике. Как разбивать пакет данных на элементы?

63
00:06:53,780 --> 00:06:58,900
Что же я имею ввиду? Представим, что мои данные это предложение

64
00:07:00,300 --> 00:07:07,140
"Здесь написано простое предложение!" У меня четыре слова и один восклицательный знак

65
00:07:07,140 --> 00:07:13,000
Я могу разбить это предложение на элементы. Для любителей математики: это называется "лексический анализ"

66
00:07:13,000 --> 00:07:20,920
Каждый из этих элементов называется "токен". А процесс называется "разбиение на токены". В итоге я хочу разбить на токены мои данные

67
00:07:20,920 --> 00:07:33,400
Я хочу найти найти логические границы и достать каждый элемент, который чип добавляет в пакет и отправляет по сети. Нельзя просто так взять большой кусок данных. Это бессмысленно

68
00:07:33,600 --> 00:07:42,820
Далее происходит "семантический анализ". Предположим, что мне повезло. Я правильно разбил данные на токены

69
00:07:42,820 --> 00:07:47,340
Теперь я хочу понять: что это за элемент? на что я смотрю?

70
00:07:47,340 --> 00:07:58,060
И я хочу, чтобы компьютер помог мне понять это. На диаграмме ранее я показывал, что они все выглядят одинаково, и я хочу, чтобы эту информацию компьютер выводил мне. Что он и делает

71
00:07:58,120 --> 00:08:02,860
Давайте скопипастим 64-битную нагрузку

72
00:08:02,920 --> 00:08:09,060
Допустим модуль А в машине общается с модулем В. Тормоза общаются с модулем контроля шасси

73
00:08:09,060 --> 00:08:14,820
Он отсылает 64 бита. Еще 64 бита. Раз за разом. Много раз

74
00:08:14,820 --> 00:08:16,820
Возможно, посылки синхронизированы, а, может, и нет

75
00:08:16,820 --> 00:08:21,020
В общем шлёт снова и снова. Тот же формат, та же ширина нагрузки

76
00:08:21,020 --> 00:08:24,400
А я наблюдаю за этим и записываю

77
00:08:24,400 --> 00:08:30,780
Вы можете взять эти 64 бита и отрисовать на графике или сделать еще что-то. Скорее всего получится бессмыслица

78
00:08:30,780 --> 00:08:37,400
Или вы можете разбить эту нагрузку. Провести лексический анализ. Ок. Возьмём биты от 0го до 6го

79
00:08:37,420 --> 00:08:43,540
Смотрим только на них и интерпритируем как одно целое. 7й бит будет значить что-то еще

80
00:08:43,540 --> 00:08:48,620
Я разбиваю весь пакет, точно так же, как и предложение ранее. Нахожу отдельные слова

81
00:08:48,620 --> 00:08:52,160
А потом извлекаю. Это, кстати, реальный пример данных из машины

82
00:08:52,160 --> 00:08:56,140
Если посмотреть на биты с 16го по 32й

83
00:08:56,140 --> 00:08:57,660
Это скорость автомобиля

84
00:08:57,660 --> 00:09:02,540
В битах 32-39 лежит копия скорости

85
00:09:02,540 --> 00:09:06,140
Точнее это не скорость. Это количество оборотов колеса

86
00:09:06,140 --> 00:09:10,260
Нетрудно заметить, что тут четыре сигнала и немного метаданных в начале

87
00:09:10,260 --> 00:09:15,160
Это один из примеров, как могут быть выходные данные

88
00:09:15,160 --> 00:09:21,460
Итак, как же мне разбивать данные? Как делать это автоматически? Как научить этому компьютер?

89
00:09:21,460 --> 00:09:28,720
Ок. Вот передо мной список 10-битных пакетов. Все видят?

90
00:09:28,780 --> 00:09:33,920
Первый пакет: 0111 000 000

91
00:09:33,920 --> 00:09:36,340
Через какое-то время

92
00:09:36,340 --> 00:09:40,980
Микроконтроллер отсылает другой 10-битовый пакет

93
00:09:40,980 --> 00:09:47,340
1000 и тд. На слайде ось времени направлена сверху вниз

94
00:09:47,340 --> 00:09:50,060
А слева направо расположены биты

95
00:09:50,140 --> 00:09:57,460
Очень хороший способ предположить логические границы элементов это поиск младших(LSB) и старших(MSB) битов

96
00:09:57,460 --> 00:10:08,620
Если данные не шифруются и в них намеренно не переставляются биты туда-сюда, вам нужно их найти

97
00:10:08,620 --> 00:10:15,180
Как это делается. Если, я возьму для соседних пакета

98
00:10:15,180 --> 00:10:18,060
и сделаю между ними Xor (исключающее или)

99
00:10:18,060 --> 00:10:24,860
вы узнаете, как часто меняется какой-то из битов

100
00:10:24,860 --> 00:10:30,460
Теперь если я просуммирую колонку с результатами всех xor'ов

101
00:10:30,460 --> 00:10:36,920
Я получу очень хороший индикатор, где находятся MSB и LSB

102
00:10:36,920 --> 00:10:39,560
Как видно на слайде 1247

103
00:10:39,560 --> 00:10:44,380
Затем разрыв и еще один логический элемент 137

104
00:10:44,380 --> 00:10:49,460
В нашем случае правый элемент из трёх битов считал от одно до семи или что-то типо того

105
00:10:49,460 --> 00:10:55,560
Ну и когда вы нарусаете график, всё становится еще более очевидным. Особенно для людей. Вы можете сразу заметить кривую

106
00:10:55,600 --> 00:11:02,980
Здесь подъём, потом пустота и еще один подъём. Ок. Вероятно, тут у нас два элемента

107
00:11:03,240 --> 00:11:06,280
Теперь я могу делать обоснованные предположения

108
00:11:07,140 --> 00:11:10,080
Как же работает этот процесс?

109
00:11:10,080 --> 00:11:16,140
Те, кто знаком с поиском восхождением или машинным обучением, наверняка понимают, о чём я говорю

110
00:11:16,140 --> 00:11:19,960
Тут происходит именно это. Вы начинате у подножия или на вершине

111
00:11:19,960 --> 00:11:23,920
А дальше просто идёте, пока не найдёте LSB, который меняет своё значение очень много раз

112
00:11:23,920 --> 00:11:25,920
 А потом внезапно будет резкий спад

113
00:11:26,440 --> 00:11:30,940
Скорее всего это граница между LSB и другим элементом в пакете

114
00:11:30,940 --> 00:11:32,940
 Поэтому здесь я ставлю границу

115
00:11:33,100 --> 00:11:35,260
 Я запоминаю, сколько бит занимает элемент

116
00:11:35,260 --> 00:11:40,000
 И откладываю. Элементо номер один. Начинаю сначала. Элемент номер два

117
00:11:40,000 --> 00:11:44,600
 Бит номер 15... 16, 17, 18. Попался!

118
00:11:44,600 --> 00:11:47,920
Дохожу до 32го. Щёлк. Здесь граница

119
00:11:47,920 --> 00:11:51,120
Кладу в элемент номер два только эти биты

120
00:11:51,200 --> 00:11:56,320
 Посмотрим на них позже. Еще раз, это данные из реальной машины

121
00:11:56,320 --> 00:12:00,080
 Я не добавлял в алгоритм никаких эвристик

122
00:12:00,240 --> 00:12:05,300
Всё действительно так легко и просто во многих случаях. Не всегда, но часто

123
00:12:05,340 --> 00:12:10,700
Всё, что нужно, это научить компьютер разбивать пакеты на элементы

124
00:12:10,700 --> 00:12:12,500
 И в итоге получать информацию

125
00:12:12,500 --> 00:12:17,540
Но, Брент, даже если я разобью всё верно, откуда мне знать, что за информация внутри?

126
00:12:17,740 --> 00:12:20,720
Ну да. Это верно

127
00:12:21,720 --> 00:12:28,860
Один парень в этой аудитории уже слышал полную версию. Мне реально потребуется два с половиной часа, чтобы объяснить эту часть

128
00:12:28,860 --> 00:12:32,680
Не думаю, что это выстрелит. Я не хочу, чтобы люди уснули

129
00:12:32,880 --> 00:12:38,060
Просто заходите на github, если вам интересно

130
00:12:38,060 --> 00:12:44,180
И посмотрите, что там есть. Там есть очень хорошая документация. Если вы хотите узнать, как отличать

131
00:12:44,180 --> 00:12:47,480
Один тип информации от другого. Это семантический анализ

132
00:12:47,520 --> 00:12:51,800
Я покажу еще несколько примеров

133
00:12:51,800 --> 00:12:54,640
Я бы хотел, чтобы вы понимали, на что вы смотрите

134
00:12:54,640 --> 00:13:01,320
 На этом слайде очень маленкий шрифт. Если у кого-то орлиное зрение, вы, наверное, можете это прочитать, но вряд ли

135
00:13:01,320 --> 00:13:04,900
Что я сделал, я натравил алгоритм на данные из машины

136
00:13:05,020 --> 00:13:11,380
Кажется, там порядка 120 id, которые рассылают по сети самую разную дичь

137
00:13:11,380 --> 00:13:19,340
Он брал элементы из разных пакетов в машине: "О вот эта штука похожа на эту. И на эту. И на эту..."

138
00:13:19,340 --> 00:13:30,180
 И в итоге он говорил: "Ну вот, мистер Хакер. Вот все яблоки, вот апельсины, вот бананы из этой тачки"

139
00:13:30,240 --> 00:13:33,840
Я не знаю, как это называется, но эти штуки очень похожи друг на друга

140
00:13:33,840 --> 00:13:37,320
Так что вам не нужно самостоятельно делать это. Код сделает всё за вас

141
00:13:37,320 --> 00:13:45,280
И, кстати, именно в этом примере мне удалось запустить диагностику J1979 в своём Приусе

142
00:13:45,280 --> 00:13:52,920
Пожалуй, я консерватор. Если вы спросите у других военных, они ездят на больших внедорожниках и тд

143
00:13:53,040 --> 00:14:03,520
Я сказал: "Дай-ка мне скорость машины, пока собираешь эти пакеты". И он мне её выдал, достав её из имеющихся пакетов

144
00:14:03,620 --> 00:14:11,480
 Я не буду говорить о достижении какой-то точности в условиях отсутствия *истинных* данных

145
00:14:11,480 --> 00:14:17,240
Однако я обнаружил, что большую часть времени эта штука была на 99% точна, пока мы испытывали её на 17 автомобилях

146
00:14:17,240 --> 00:14:19,720
Она может иметь разброс на бит или два

147
00:14:19,720 --> 00:14:25,180
Для тех, кто с этим работает, вы знаете, что "бит или два" это серьёзная проблема

148
00:14:25,180 --> 00:14:25,200
Но она без сомнений поможет вам забраться очень глубоко и при этом спать у себя дома
Для тех, кто с этим работает, вы знаете, что "бит или два" это серьёзная проблема

149
00:14:25,200 --> 00:14:28,980
Но она без сомнений поможет вам забраться очень глубоко и при этом спать у себя дома

150
00:14:28,980 --> 00:14:32,840
или вы хотя бы будет понимать, что производитель действительно продал вам то, что вы хотели

151
00:14:32,840 --> 00:14:34,840
Или вы новичок и просто хотите показать это друзьям

152
00:14:34,840 --> 00:14:37,260
Ладно, давайте что-нибудь зареверсим!

153
00:14:37,260 --> 00:14:40,100
Еще раз, я хочу разбить демонстрацию на три части

154
00:14:40,100 --> 00:14:44,720
В первой я просто пробегусь по слайдам, потому что это не мой компьютер

155
00:14:44,720 --> 00:14:49,460
Я покажу данные из всех 17 машин. Это будет результат семантического анализа

156
00:14:49,460 --> 00:14:52,520
Разобьём пакеты, дадим элементам имена, найдём среди них похожие

157
00:14:52,520 --> 00:14:56,540
Я также докажу вам, что я ничего не подкручивал, ни под одну машину

158
00:14:56,540 --> 00:15:01,620
Я просто задаю несколько параметров, запускаю и на каждой машине она мне что-то выдаёт

159
00:15:01,680 --> 00:15:05,500
На второй демонстрации я буду открыт для вопросов и дам людям взглянуть, как это работает

160
00:15:05,500 --> 00:15:10,100
Но по-честному она просто помогает понять, сколько времени всё это занимает

161
00:15:10,200 --> 00:15:17,480
И во время третьей демонстрации я буду в кородоре или где-то в сторонке

162
00:15:17,480 --> 00:15:20,180
С этим кодом, который ищет что-то среди тестовых данных

163
00:15:20,180 --> 00:15:24,040
На случай если вы захотите поговорить об этом или посмотреть, как это всё выглядит в риалтайме

164
00:15:24,040 --> 00:15:26,040
Я с удовольствием покажу

165
00:15:28,040 --> 00:15:32,140
На экране вы видите два столбца

166
00:15:32,140 --> 00:15:36,420
Каждый соответсвует машине

167
00:15:36,420 --> 00:15:42,780
Здесь выведен результат работы. Все элементы выделены, проведён семантический анализ, обнаружены похожие элементы и сгруппированы вместе

168
00:15:42,840 --> 00:15:45,360
Я ничего не делал. Оно просто выдало мне это со словами: "Наслаждайся"

169
00:15:45,600 --> 00:15:49,140
Ок. Слева одна машина, справа другая

170
00:15:49,140 --> 00:15:52,860
Если написано "Cropped to fit" это значит, что графиков было много

171
00:15:52,860 --> 00:15:55,900
Я старался оставить всё читабельным

172
00:15:55,900 --> 00:16:00,920
Поэтому несколько сигналов я вырезал, чтобы мы видели хотя бы часть

173
00:16:02,140 --> 00:16:04,480
На правой стороне

174
00:16:04,480 --> 00:16:08,780
Тут нужно заметить, что все пакеты были собраны в рамках одного сценария

175
00:16:08,840 --> 00:16:10,660
 У меня были знакомые на парковке

176
00:16:10,980 --> 00:16:14,700
Мы спускались с небольшого холма,

177
00:16:14,740 --> 00:16:17,000
проезжали порядка пяти-шести километров

178
00:16:17,000 --> 00:16:20,680
Нажимали на тормоз, делали много поворотов направо и тд

179
00:16:20,680 --> 00:16:22,680
И возвращались на парковку

180
00:16:22,680 --> 00:16:26,560
Видно, как [скорость?] поднимается, затем мы остановились, снова поднимает и снова остановка

181
00:16:27,200 --> 00:16:31,120
Также часто, как в случае с машиной номер три,

182
00:16:31,120 --> 00:16:33,120
Если вы когда-нибудь имели дело с CAN сетями,

183
00:16:33,120 --> 00:16:37,000
Control Area Networks в автомобилях. Производители часто добавляют в пакеты счётчики

184
00:16:37,000 --> 00:16:39,920
Они помогают отслеживать ошибки

185
00:16:39,920 --> 00:16:43,020
В нашем случае программа нашла кучу счётчиков в машине номер три

186
00:16:43,020 --> 00:16:45,900
Справа по всей видимости графики скорости машины номер 4

187
00:16:46,560 --> 00:16:48,780
Это я пропущу

188
00:16:49,080 --> 00:16:54,600
Внизу ссылка на github. Там есть один сэмпл с моей личной машины

189
00:16:54,600 --> 00:16:58,640
Вы можете с ним поиграться. Склонируйте репозиторий

190
00:16:58,640 --> 00:17:02,040
Загрузите этот сэмпл и начинайте хачить

191
00:17:03,080 --> 00:17:08,400
Опять же видно, что паттерны очень похожи. Я старался, чтобы все сэмплы были похожи

192
00:17:08,400 --> 00:17:13,920
С 11й машиной были проблемы. По всей видимости тут потерян один бит во втором сигнале

193
00:17:14,320 --> 00:17:20,640
Здесь мы едем вокруг холма

194
00:17:20,720 --> 00:17:25,700
Короче 17 тачек. Это было что-то типо пруф-1, пруф-2. Я планирую загрузить видео

195
00:17:25,700 --> 00:17:28,880
У кого-нибудь есть вопросы?

196
00:17:29,160 --> 00:17:33,580
Похоже, многие стесняются. Вы можете просто подойти и спросить, если стесняетесь говорить перед всеми

197
00:17:33,580 --> 00:17:40,760
Ну и потом я с удовольствием покажу, как оно работает на моём компьютере. Большое спасибо

