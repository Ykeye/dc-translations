1
00:00:06,893 --> 00:00:07,761
Привет!

2
00:00:08,086 --> 00:00:14,577
Перед вами первое видео нашего проекта по переводу и озвучиванию выступлений с конференций DefCon

3
00:00:14,625 --> 00:00:17,870
Если вам захочется нам помочь переводом субтитров или их озвучиванием

4
00:00:17,947 --> 00:00:22,772
напишите об этом в чате DC7495

5
00:00:22,880 --> 00:00:28,283
или можете сразу присоединиться к переводам на нашем гитхаб-репозитории

6
00:00:28,591 --> 00:00:34,292
Данное видео является переводом выступления Брента Стоуна на DefCon 27

7
00:00:34,854 --> 00:00:39,888
Брент Стоун является офицером информационной безопасности Вооружённых Сил США

8
00:00:40,011 --> 00:00:44,943
В своём выступлении он расскажет о своей разработке по реверс-инжинирингу автомобилей

9
00:00:45,003 --> 00:00:47,194
разработка которого ведётся в гитхабе

10
00:00:47,718 --> 00:00:51,792
Информация по проекту переводов и докладу в описании

11
00:00:52,000 --> 00:00:56,440
Вы наверное скажете: "Брэнт, это отличный заголовок, но...

12
00:00:56,540 --> 00:00:59,400
у меня нет 17 машин.

13
00:01:00,680 --> 00:01:02,940
Что мне с этим делать?

14
00:01:03,220 --> 00:01:09,640
Ладно. Кто тут новичок, поднимите руку. Вот так. Ага, спасибо за честность.

15
00:01:10,760 --> 00:01:14,360
Это поможет вам начать с чего-нибудь весёлого

16
00:01:14,440 --> 00:01:18,580
к боли мы потом перейдём

17
00:01:18,660 --> 00:01:20,580
Я просто хочу помочь новичкам, понимаете?

18
00:01:21,220 --> 00:01:25,300
Кого-нибудь заказчик просил установить мощный двигатель в минивэн?

19
00:01:25,300 --> 00:01:31,520
Во. Этот парень познал боль. Я хочу чтобы ты уходил домой пораньше, а жена и дети видели как ты улыбаешься

20
00:01:31,680 --> 00:01:38,120
Но простым обыватеям это тоже будет полезно. Например, кто-нибудь помнит скандал с Volkswagen и Дизельгейт?

21
00:01:38,840 --> 00:01:47,380
Теперь вы сможете получить данные из машины, не тратя кучу времени на исследование. Компьютер просто делает "Пип!", и вся информация у вас в руках

22
00:01:47,400 --> 00:01:51,600
И вы такой "Ой-ой. А в салоне то говорили совсем другое

23
00:01:51,600 --> 00:01:56,000
... У меня же должен был быть чистый дизель, а то что я вижу, совсем на него не похоже"

24
00:01:56,000 --> 00:02:05,660
Мой код именно для этого. Я понимаю, ни у кого нет 17 машин, чтобы испытывать его на каждой из них. Но  вся соль именно его в универсальности

25
00:02:05,820 --> 00:02:13,660
И еще один плюс: код применим не только к автомобилям. Я к этому вернусь позже

26
00:02:13,780 --> 00:02:21,000
SCADA системы, всё, что угодно, где один компьютер отсылает другому пакеты фиксированной длины и где нету никаких метаданных

27
00:02:21,000 --> 00:02:28,520
Эта штука поможет вам, какой бы ни была ваша цель. Это не только про тачки

28
00:02:28,620 --> 00:02:34,500
Так, небольшой дисклэймер: я служу в армии. Всё, что я говорю, моя личное мнение.

29
00:02:34,500 --> 00:02:38,700
Оно не выражает позицию Министерства Обороны, Армии США, ВВС США

30
00:02:39,040 --> 00:02:45,920
или кого-то еще кроме меня. Если я говорю глупость, это моя вина, не Америки.

31
00:02:46,940 --> 00:02:54,760
Так, сейчас будет серьёзное упрощение, но помните, я новичёк, пожалуйста, не издевайтесь надо мной после этого.

32
00:02:54,760 --> 00:02:57,960
Давайте разделим все сети на две вкуса

33
00:02:57,960 --> 00:03:01,800
Первый, ванильный: General Use Network

34
00:03:01,960 --> 00:03:09,360
Основная цель: быть гибкой. Например, интернет. Я хочу добавлять/удалять хосты и соединения

35
00:03:09,420 --> 00:03:14,840
Меня не волнует, что происходит в ней. Я просто хочу подключиться и взаимодействовать с чем-то в ней

36
00:03:14,840 --> 00:03:20,880
Но тут в жертву приносятся гарантии. У вас нет гарантий, что сообщение дойдёт до адресата

37
00:03:20,880 --> 00:03:24,580
Нет гарантий, *когда* оно до него дойдёт. Возможно, придётся отправить его еще раз

38
00:03:24,580 --> 00:03:31,520
Возможно, придётся сказать: "Это мой IP. Какой у тебя?" И всё это заворачивается в кучу метаданных

39
00:03:31,520 --> 00:03:39,060
И нужно это для того, чтобы быть уверенным, что сообщение будет доставлено в целости и сохранности. Поэтому в сетях общего пользования много метаданных

40
00:03:39,060 --> 00:03:48,920
С другой стороны спектра всё ровно наоборот. Мне не нужна гибкость. Я хочу гарантий. Когда я жму тормоз, я хочу, чтобы машина останавливалась.

41
00:03:48,920 --> 00:03:54,900
Я не хочу, чтобы сообщение о нажатии на педаль пересылалось заново. Я хочу, чтобы оно работало с первого раза и вовремя

42
00:03:54,920 --> 00:03:58,860
Поэтому мне нужна гарантия, что сообщение будет доставлено и что это произойдёт вовремя

43
00:03:58,860 --> 00:04:03,400
Эта сеть называется Control Network. В них вы лишаетесь гибкости

44
00:04:03,400 --> 00:04:11,260
Вы не добавите еще одно колесо к своей машине. Кто здесь хочеть добавить еще колесо? Есть психи?

45
00:04:11,260 --> 00:04:16,820
Здесь вы об этом не беспокоитесь. Тут важна гарантия доставки и времени

46
00:04:16,820 --> 00:04:20,600
Код, о котором я расскажу фокусируется именно на Control Networks

47
00:04:20,600 --> 00:04:32,620
Из-за этого его применение ограничено. В General Use Network у вас есть сочные метаданные. Заглянув в них, вы увидите кучу тегов. Вероятно, вам даже не нужно ковыряться в нагрузке [payload]

48
00:04:32,620 --> 00:04:36,300
Достаточно лишь взглянуть на метаданные, но их нет в Control Network.

49
00:04:36,340 --> 00:04:43,120
В тачке только биты: 64 бита... еще 64 бита. Там вообще нет метаданных

50
00:04:43,180 --> 00:04:51,180
Полно народу поумнее меня уже сделало кучу всего, что позволит вам поиграться с General Use Network

51
00:04:51,180 --> 00:04:58,720
По крайней мере с тем, что Брент ими называет. VoIP, внутренние сети, смартфоны, IoT

52
00:04:58,720 --> 00:05:08,780
В дополнение к исследованиям, есть Wireshark, есть snork. Масса штук, которые можно подключить к чему-то опенсоурсному или широко используемому

53
00:05:08,780 --> 00:05:12,780
Есть масса исследований, которые проводят ядерные интеллектулы, пытаясь решить какую-либо задачу

54
00:05:12,780 --> 00:05:25,620
Например последние четыре статьи. Кажется, их можно скачать с сервера DefCon. Если вы хотите упороться и полистать, на мой взгляд в них проведена отличную работу в автоматизации реверс-инжиниринга General Use Network

55
00:05:25,660 --> 00:05:33,560
Но я хочу поиграться с тачками! Или с медоборудованием. Или с самолётами. Или с поездами. Или еще с чем-то

56
00:05:33,560 --> 00:05:41,240
Но нет ничего, что вам бы помогло в этом... Точнее не было. Давайте я покажу, что она может

57
00:05:41,240 --> 00:05:49,260
Я хочу получить кучу сырых данных из Control Network. Я жму на кнопку. Бум! Оно выплёвывает полезную и актуальную информацию

58
00:05:49,260 --> 00:05:55,960
Возможно, где-то я ошибусь на бит или два, но в целом достоверность порядка 99%. Короче, я просто хочу волшебства

59
00:05:56,080 --> 00:06:02,140
Итак, что же делает код. Я выложил его на github, об этом я расскажу чуть позже

60
00:06:02,140 --> 00:06:13,480
Брент, что ты творишь на этом слайде? Что всё это значит? Выглядит как таблица окулиста (eye chart). В армии мы называем это nye chart. "Зачем ты это показываешь? Я это не заслуживаю!"

61
00:06:13,480 --> 00:06:19,640
Клёвый момент в том, что, когда вы зайдёте на github, не пугайтесь. Единственное, что вам нужно это препроцессинг

62
00:06:19,640 --> 00:06:31,460
Все элементы слабо связаны, поэтому вы можете легко взять другой протокол... Я уже это делал, кстати... Взять совершенно другой протокол, не трогая примерно 90% кода, и эта штука зареверсит его автоматически

63
00:06:31,480 --> 00:06:36,400
Поэтому она применима не только к автомобилям. Если вы заснифали данные с медицинского оборудования

64
00:06:36,460 --> 00:06:50,760
И выполняется условие, что передаваемые данные всегда имеют фиксированный размер: 2 байта, 64 бита и тд. Этот софт скорее всего будет вам полезен

65
00:06:50,900 --> 00:07:04,200
Чуть позже я покажу пример использования. На самом деле три примера. Мы подготовили всё и подключили мой ноутбук. Так что будет три демки, чтобы удовлетворить всех, кто смотрит эту презентацию

66
00:07:04,320 --> 00:07:13,900
Демо состоит из двух частей. Это показывает как быстро работает софт. К примеру, если вы подключитесь к ARM чипу

67
00:07:14,000 --> 00:07:18,620
или какой-нибудь SoC. И он будет работать эффективно. Очень эффективно

68
00:07:18,620 --> 00:07:22,420
Ну и вторая часть: как реверсить сам протокол

69
00:07:22,420 --> 00:07:31,660
В частности на слайдах я покажу *ментальный подход* к изучению и ковырянию в данных, чтобы достать конкретную информацию

70
00:07:31,660 --> 00:07:38,320
Ну и еще куча всего лежит в репозитории. Опять же, не беспокойтесь об этом. Вам нужно разобраться только с первой частью

71
00:07:38,420 --> 00:07:45,780
Ладно, давайте пока.. Забудем про код и разберёмся в логике. Как разбивать пакет данных на элементы?

72
00:07:45,780 --> 00:07:50,900
Смотрите, что я имею ввиду. Представим, что мои данные это предложение

73
00:07:52,300 --> 00:07:59,140
"Здесь написано простое предложение!" У меня четыре слова и один восклицательный знак

74
00:07:59,140 --> 00:08:05,000
Я могу разбить это предложение на элементы. Для любителей математики: это называется "лексический анализ"

75
00:08:05,000 --> 00:08:12,920
Каждый из этих элементов называется "токен". А процесс называется "разбиение на токены". В итоге я хочу разбить на токены мои данные

76
00:08:12,920 --> 00:08:25,400
Я хочу найти найти логические границы и извлечь каждый элемент, который чип добавляет в пакет и отправляет по сети. Нельзя брать большой кусок данных. Это просто бессмысленно

77
00:08:25,600 --> 00:08:34,820
Далее происходит "семантический анализ". Предположим, что мне повезло. Я правильно разбил данные на токены

78
00:08:34,820 --> 00:08:39,340
Теперь я хочу понять: что это за элемент? на что я смотрю?

79
00:08:39,340 --> 00:08:50,060
И я хочу, чтобы компьютер помог мне понять это. На диаграмме ранее я показывал, что они все выглядят одинаково, и я хочу, чтобы эту информацию компьютер выводил мне. Что он и делает

80
00:08:50,120 --> 00:08:54,860
Давайте скопипастим 64-битную нагрузку

81
00:08:54,920 --> 00:09:01,060
Допустим модуль А в машине общается с модулем В. Тормоза общаются с модулем контроля шасси

82
00:09:01,060 --> 00:09:06,820
Он отсылает 64 бита. Еще 64 бита. Раз за разом. Много раз

83
00:09:06,820 --> 00:09:08,820
Возможно, посылки синхронизированы, а, может, и нет

84
00:09:08,820 --> 00:09:13,020
В общем шлёт снова и снова. Тот же формат, та же ширина нагрузки

85
00:09:16,400 --> 00:09:22,780
Вы можете взять эти 64 бита и отрисовать на графике или сделать еще что-то. Скорее всего получится бессмыслица

86
00:09:22,780 --> 00:09:29,400
Или вы можете разбить эту нагрузку. Провести лексический анализ. Ок. Возьмём биты от 0го до 6го

87
00:09:29,420 --> 00:09:35,540
Смотрим только на них и интерпритируем как одно целое. 7й бит будет значить что-то еще

88
00:09:35,540 --> 00:09:40,620
Я разбиваю весь пакет, точно так же, как и предложение ранее. Нахожу отдельные слова

89
00:09:40,620 --> 00:09:44,160
А потом извлекаю. Это, кстати, реальный пример данных из машины

90
00:09:44,160 --> 00:09:48,140
Если посмотреть на биты с 16го по 32й

91
00:09:48,140 --> 00:09:49,660
Это скорость автомобиля

92
00:09:49,660 --> 00:09:54,540
В битах 32-39 лежит копия скорости

93
00:09:54,540 --> 00:09:58,140
Точнее сказать, это не совсем скорость. Это количество оборотов колеса

94
00:09:58,140 --> 00:10:02,260
Нетрудно заметить, что тут четыре сигнала и немного метаданных в начале

95
00:10:02,260 --> 00:10:07,160
Это один из примеров, как могут быть выходные данные

96
00:10:07,160 --> 00:10:13,460
Итак, как же мне разбивать данные? Как делать это автоматически? Как научить этому компьютер?

97
00:10:13,460 --> 00:10:20,720
Ок. Вот передо мной список 10-битных пакетов. Все видят?

98
00:10:20,780 --> 00:10:25,920
Первый пакет: 0111 000 000

99
00:10:25,920 --> 00:10:28,340
Через какое-то время

100
00:10:28,340 --> 00:10:32,980
Микроконтроллер отсылает другой 10-битовый пакет

101
00:10:32,980 --> 00:10:39,340
1000 и тд. На слайде ось времени направлена сверху вниз

102
00:10:39,340 --> 00:10:42,060
А слева направо расположены биты

103
00:10:42,140 --> 00:10:49,460
Очень хороший способ предположить логические границы элементов это поиск младших(LSB) и старших(MSB) битов

104
00:10:49,460 --> 00:11:00,620
Если данные не шифруются и в них намеренно не переставляются биты туда-сюда, вам нужно их найти

105
00:11:00,620 --> 00:11:07,180
Как это делается. Допустим, я возьму для соседних бита

106
00:11:07,180 --> 00:11:10,060
и сделаю между ними Xor (исключающее или)

107
00:11:10,060 --> 00:11:16,860
вы узнаете, как часто меняется какой-то из битов

108
00:11:16,860 --> 00:11:22,460
Теперь если я просуммирую колонку с результатами всех xor'ов

109
00:11:22,460 --> 00:11:28,920
Я получу очень хороший индикатор, где находятся MSB и LSB

110
00:11:28,920 --> 00:11:31,560
Как видно на слайде 1247

111
00:11:31,560 --> 00:11:36,380
Затем разрыв и еще один логический элемент 137

112
00:11:36,380 --> 00:11:41,460
В нашем случае правый элемент из трёх битов считал от одно до семи или что-то типо того

113
00:11:41,460 --> 00:11:47,560
Ну и когда вы нарусаете график, всё становится еще более очевидным. Особенно для людей. Вы можете сразу заметить кривую

114
00:11:47,600 --> 00:11:54,980
Здесь подъём, потом пустота и еще один подъём. Ок. Вероятно, тут у нас два элемента

115
00:11:55,240 --> 00:11:58,280
Теперь я могу делать обоснованные предположения

116
00:11:59,140 --> 00:12:02,080
Как же работает этот процесс?

117
00:12:02,080 --> 00:12:08,140
Те, кто знаком с поиском восхождением или машинным обучением, наверняка понимают, о чём я говорю

118
00:12:08,140 --> 00:12:11,960
Тут происходит именно это. Вы начинате у подножия или на вершине

119
00:12:11,960 --> 00:12:15,920
А дальше просто идёте, пока не найдёте LSB, который меняет своё значение очень много раз

120
00:12:15,920 --> 00:12:17,920
А потом внезапно будет резкий спад

121
00:12:18,440 --> 00:12:22,940
Скорее всего это граница между LSB и другим элементом в пакете

122
00:12:22,940 --> 00:12:24,940
Поэтому здесь я ставлю границу

123
00:12:25,100 --> 00:12:27,260
Я запоминаю, сколько бит занимает элемент

124
00:12:27,260 --> 00:12:32,000
И откладываю. Бит номер один. Начинаю сначала. Бит номер два

125
00:12:32,000 --> 00:12:36,600
Бит номер 15... 16, 17, 18. Попался!

126
00:12:36,600 --> 00:12:39,920
Дохожу до 32го. Щёлк. Здесь граница

127
00:12:39,920 --> 00:12:43,120
Кладу в элемент номер два только эти биты

128
00:12:43,200 --> 00:12:48,320
Посмотрим на них позже. Еще раз, это данные из реальной машины

129
00:12:48,320 --> 00:12:52,080
Я не добавлял в алгоритм никаких эвристик

130
00:12:52,240 --> 00:12:57,300
Всё действительно так легко и просто во многих случаях. Не всегда, но часто

131
00:12:57,340 --> 00:13:02,700
Всё, что нужно, это научить компьютер разбивать пакеты на элементы

132
00:13:02,700 --> 00:13:04,500
И в итоге получать информацию

133
00:13:04,500 --> 00:13:09,540
Но, Брент, даже если я разобью всё верно, откуда мне знать, что за информация внутри?

134
00:13:09,740 --> 00:13:12,720
Ну да. Это верно

135
00:13:13,720 --> 00:13:20,860
Один парень в этой аудитории уже слышал полную версию. Мне реально потребуется два с половиной часа, чтобы объяснить эту часть

136
00:13:20,860 --> 00:13:24,680
Не думаю, что это выстрелит. Я не хочу, чтобы люди уснули

137
00:13:24,880 --> 00:13:30,060
Просто заходите на github, если вам интересно

138
00:13:30,060 --> 00:13:36,180
И посмотрите, что там есть. Там есть очень хорошая документация. Если вы хотите узнать, как отличать

139
00:13:36,180 --> 00:13:39,480
Один тип информации от другого. Это семантический анализ

140
00:13:39,520 --> 00:13:43,800
Я покажу еще несколько примеров

141
00:13:43,800 --> 00:13:46,640
Я бы хотел, чтобы вы понимали, на что вы смотрите

142
00:13:46,640 --> 00:13:53,320
На этом слайде очень маленкий шрифт. Если у кого-то орлиное зрение, вы, наверное, можете это прочитать, но вряд ли

143
00:13:53,320 --> 00:13:56,900
Что я сделал, я натравил алгоритм на данные из машины

144
00:13:57,020 --> 00:14:03,380
Кажется, там порядка 120 id, которые рассылают по сети самую разную дичь

145
00:14:03,380 --> 00:14:11,340
Он брал элементы из разных пакетов в машине: "О вот эта штука похожа на эту. И на эту. И на эту..."

146
00:14:11,340 --> 00:14:22,180
И в итоге он говорил: "Ну вот, мистер Хакер. Вот все яблоки, вот апельсины, вот бананы из этой тачки"

147
00:14:22,240 --> 00:14:25,840
Я не знаю, как это называется, но эти штуки очень похожи друг на друга

148
00:14:25,840 --> 00:14:29,320
Так что вам не нужно самостоятельно делать это. Код сделает всё за вас

149
00:14:29,320 --> 00:14:37,280
И, кстати, именно в этом примере мне удалось запустить диагностику J1979 в своём Приусе

150
00:14:37,280 --> 00:14:44,920
Пожалуй, я консерватор. Если вы спросите у других военных, они ездят на больших внедорожниках и тд

151
00:14:45,040 --> 00:14:55,520
Я сказал: "Дай-ка мне скорость машины, пока собираешь эти пакеты". И он мне её выдал, достав её из имеющихся пакетов

152
00:14:55,620 --> 00:15:03,480
Я не буду говорить о достижении какой-то точности в условиях отсутствия *истинных* данных

153
00:15:03,480 --> 00:15:09,240
Однако я обнаружил, что большую часть времени эта штука была на 99% точна, пока мы испытывали её на 17 автомобилях

154
00:15:09,240 --> 00:15:11,720
Она может иметь разброс на бит или два

155
00:15:11,720 --> 00:15:17,180
Те, кто с этим работает, знают, что "бит или два" это серьёзная проблема

156
00:15:17,200 --> 00:15:20,980
Но она без сомнений поможет вам забраться очень глубоко и при этом спать у себя дома

157
00:15:20,980 --> 00:15:24,840
или вы хотя бы будет понимать, что производитель действительно продал вам то, что вы хотели

158
00:15:24,840 --> 00:15:26,840
Или вы новичок и просто хотите показать это друзьям

159
00:15:26,840 --> 00:15:29,260
Ладно, давайте что-нибудь зареверсим!

160
00:15:29,260 --> 00:15:32,100
Еще раз, я хочу разбить демонстрацию на три части

161
00:15:32,100 --> 00:15:36,720
В первой я просто пробегусь по слайдам, потому что это не мой компьютер

162
00:15:36,720 --> 00:15:41,460
Я покажу данные из всех 17 машин. Это будет результат семантического анализа

163
00:15:41,460 --> 00:15:44,520
Разобьём пакеты, дадим элементам имена, найдём среди них похожие

164
00:15:44,520 --> 00:15:48,540
Я также докажу вам, что я ничего не подкручивал, ни под одну машину

165
00:15:48,540 --> 00:15:53,620
Я просто задаю несколько параметров, запускаю и на каждой машине она мне что-то выдаёт

166
00:15:53,680 --> 00:15:57,500
На второй демонстрации я буду открыт для вопросов и покажу, как это работает

167
00:15:57,500 --> 00:16:02,100
Но по-честному она просто помогает понять, сколько времени всё это занимает

168
00:16:02,200 --> 00:16:09,480
И во время третьей демонстрации я буду в кородоре или где-то в сторонке

169
00:16:09,480 --> 00:16:12,180
С этим кодом, который ищет что-то среди тестовых данных

170
00:16:12,180 --> 00:16:16,040
На случай если вы захотите поговорить об этом или посмотреть, как это всё выглядит в риалтайме

171
00:16:16,040 --> 00:16:18,040
Я с удовольствием покажу

172
00:16:20,040 --> 00:16:24,140
На экране вы видите два столбца

173
00:16:24,140 --> 00:16:28,420
Каждый соответсвует машине

174
00:16:28,420 --> 00:16:34,780
Здесь выведен результат работы. Все элементы выделены, проведён семантический анализ, обнаружены похожие элементы и сгруппированы вместе

175
00:16:34,840 --> 00:16:37,360
Я ничего не делал. Оно просто выдало мне это со словами: "Наслаждайся"

176
00:16:37,600 --> 00:16:41,140
Ок. Слева одна машина, справа другая

177
00:16:41,140 --> 00:16:44,860
Если написано "Cropped to fit" это значит, что графиков было много

178
00:16:44,860 --> 00:16:47,900
Я старался оставить всё читабельным

179
00:16:47,900 --> 00:16:52,920
Поэтому несколько сигналов я вырезал, чтобы мы видели хотя бы часть

180
00:16:54,140 --> 00:16:56,480
На правой стороне

181
00:16:56,480 --> 00:17:00,780
Тут нужно заметить, что все пакеты были собраны в рамках одного сценария

182
00:17:00,840 --> 00:17:02,660
У меня были знакомые на парковке

183
00:17:02,980 --> 00:17:06,700
Мы спускались с небольшого холма,

184
00:17:06,740 --> 00:17:09,000
проезжали порядка пяти-шести километров

185
00:17:09,000 --> 00:17:12,680
Нажимали на тормоз, делали много поворотов направо и тд

186
00:17:12,680 --> 00:17:14,680
И возвращались на парковку

187
00:17:14,680 --> 00:17:18,560
Видно, как [скорость?] поднимается, затем мы остановились, снова поднимает и снова остановка

188
00:17:19,200 --> 00:17:23,120
Также часто, как в случае с машиной номер три,

189
00:17:23,120 --> 00:17:25,120
Если вы когда-нибудь имели дело с CAN сетями,

190
00:17:25,120 --> 00:17:29,000
Control Area Networks в автомобилях. Производители часто добавляют в пакеты счётчики

191
00:17:29,000 --> 00:17:31,920
Они помогают отслеживать ошибки

192
00:17:31,920 --> 00:17:35,020
В нашем случае программа нашла кучу счётчиков в машине номер три

193
00:17:35,020 --> 00:17:37,900
Справа по всей видимости графики скорости машины номер 4

194
00:17:38,560 --> 00:17:40,780
Это я пропущу

195
00:17:41,080 --> 00:17:46,600
Внизу ссылка на github. Там есть один сэмпл с моей личной машины

196
00:17:46,600 --> 00:17:50,640
Вы можете с ним поиграться. Склонируйте репозиторий

197
00:17:50,640 --> 00:17:54,040
Загрузите этот сэмпл и начинайте хачить

198
00:17:55,080 --> 00:18:00,400
Опять же видно, что паттерны очень похожи. Я старался, чтобы все сэмплы были похожи

199
00:18:00,400 --> 00:18:05,920
С 11й машиной были проблемы. По всей видимости тут потерян один бит во втором сигнале

200
00:18:06,320 --> 00:18:12,640
Здесь мы едем вокруг холма

201
00:18:12,720 --> 00:18:17,700
Короче 17 тачек. Это было что-то типо пруф-1, пруф-2. Я планирую загрузить видео

202
00:18:17,700 --> 00:18:20,880
У кого-нибудь есть вопросы?

203
00:18:21,160 --> 00:18:25,580
Похоже, многие стесняются. Вы можете просто подойти и спросить, если стесняетесь говорить перед всеми

204
00:18:25,580 --> 00:18:32,760
Ну и потом я с удовольствием покажу, как оно работает на моём компьютере. Большое спасибо

