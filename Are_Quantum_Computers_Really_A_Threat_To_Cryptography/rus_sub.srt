00:00:00.100,00:00:05.172
>>Как много здесь народа, кто разбирается в
квантовой физике? М? В общем,
перечитывал я тут конспект этого

00:00:05.172,00:00:11.545
доклада и подумал: "Может быть, из
этого выйдет неплохое выступление. 
Наверное. Хм,

00:00:11.545,00:00:16.550
а может быть, и нет.. [смех]
Думаю, я никак этого не узнаю, 
пока сам не увижу выступление,

00:00:19.453,00:00:24.458
так ведь? Логика как в какой-то детской 
книжке. Ага, зашибись. В общем, давайте 
начнем с мощных аплодисментов для

00:00:26.526,00:00:31.131
Андреаса за то, что он приехал
в Вегас аж из Австралии, 
чтобы поговорить с нами

00:00:31.131,00:00:38.005
о квантовой криптографии. [аплодисменты]
Удачи, чувак. 
> Спасибо большое! Так... Привет 

00:00:38.005,00:00:44.511
всем вам! Да, надеюсь, что после 
такого вступления вы вынесете
для себя что-то новое из этого

00:00:44.511,00:00:50.651
доклада. Так вот, квантовые компьютеры:
если вы читали что-то об этом в прессе,
вы наверняка считаете, что мы

00:00:50.651,00:00:55.088
совершенно обречены и, знаете,
конец интернетам и всё такое; или же
вы ничего такого не ожидаете, потому

00:00:55.088,00:00:59.126
что их никогда не создадут. Поэтому
я подумал, что лучше будет осветить
эту тему скорее с алгоритмических

00:00:59.126,00:01:03.196
позиций и посмотреть, чего мы 
достигли сейчас. Разговор не столько 
о хайповом, сколько об тех алгоритмах,

00:01:03.196,00:01:09.436
что мы сейчас имеем в виду. 
В общем, я основатель нескольких 
компаний в области цифровой

00:01:09.436,00:01:15.175
безопасности, начиная еще с 2002
года... а, чёрт, от этих слов
я начинаю чувствовать себя старовато.

00:01:15.175,00:01:19.580
В любом случае, в первую очередь я рад,
что выступаю сейчас на DEFCON.
Ну, вы знаете, я здесь уже многие годы,

00:01:19.580,00:01:25.185
но выступаю впервые, так что давайте 
перейдем к делу. Итак, когда мы говорим 
о криптографии, мы 

00:01:25.185,00:01:30.390
обычно подразумеваем один из двух
заметно отличающихся её видов.
Первый - это симметричные

00:01:30.390,00:01:37.331
криптосистемы с общим 
симметричным ключом - 
вроде AES. Обе стороны

00:01:37.331,00:01:42.736
осуществляют шифрование и общение
с использованием одного ключа.
Второй - асимметричные криптосистемы,

00:01:42.736,00:01:46.974
которые используют инфраструктуру
с публичным ключом, который 
вы используете, чтобы

00:01:46.974,00:01:52.045
зашифровать сообщение, а затем
расшифровываете его приватным ключом.
Существуют, гм, различные формы этой 

00:01:52.045,00:01:57.050
схемы, например, используемые 
для цифровой подписи. И, знаете,
практически каждая в этом мире

00:01:59.186,00:02:04.291
криптосистема из используемых 
прямо сейчас повсюду относится
к "вычислительно безопасным".


00:02:04.291,00:02:10.430
Они безопасны в том смысле, что,
хотя нам известны алгоритмы, которые
могут их взломать, но все они

00:02:10.430,00:02:16.737
не являются легкими - в том смысле,
что если я, знаете, попробую

00:02:16.737,00:02:21.742
взломать тот же 2048-битный 
RSA-ключ, используя обычный ПК,
это займёт пару триллионов лет,

00:02:24.111,00:02:30.417
так что очевидно, что несмотря
на существование алгоритмов взлома,
фактически шифр безопасен. Есть

00:02:30.417,00:02:35.722
также информационно-теоретические 
алгоритмы другого плана, наиболее
известный из них - это

00:02:35.722,00:02:40.694
"одноразовые шифроблокноты" или шифр
Вернама-Виженера, но они специфичны
и непригодны для использования на практике;

00:02:40.694,00:02:46.233
например, одноразовый шифр-ключ
должен быть той же длины, что
и исходное шифруемое сообщение:

00:02:46.233,00:02:49.936
так что, к примеру, если вы хотите
передать одномегабайтный файл,
вам потребуется одномегабайтный же ключ.

00:02:49.936,00:02:55.142
Проще говоря, на каждый байт 
изначально необходимых вам данных
вам потребуется еще один байт

00:02:55.142,00:03:00.013
ключа, так что вам придётся управлять
большими объемами данных ключей,
что чаще всего совершенно

00:03:00.013,00:03:05.052
непрактично. То есть такие системы
существуют, но помимо них 
практически все криптосистемы только

00:03:05.052,00:03:11.558
вычислительно безопасны.
И, если вы посмотрите на этот гм,
квантовый алгоритм... пожалуй, я рассмотрю

00:03:11.558,00:03:17.264
несколько подробнее детали в применении
к этим двум различным видам 
алгоритмов. Для нас 

00:03:17.264,00:03:22.235
будет гораздо интереснее
подробнее рассматривать асимметричные 
криптосистемы, поскольку для 

00:03:22.235,00:03:28.008
симметричных систем существует 
так называемый алгоритм Гровера,
который в основном представляет

00:03:28.008,00:03:33.013
собой вариант, позволяющий находить 
решение, аналогичное классическому,
но с квадратичным выигрышем в скорости.

00:03:35.148,00:03:38.285
По сути, в классической версии,
если я пытаюсь найти общий ключ,
мне нужно фактически

00:03:38.285,00:03:43.123
брутфорсом перебирать каждую
возможную комбинацию, что занимает 
неимоверно много времени. Мне удалось

00:03:43.123,00:03:48.662
получить квадратичное улучшение
скорости в квантовой версии перебора,
что, конечно, значительно, но

00:03:48.662,00:03:52.866
если я могу ускорить перебор, идущий
115 триллионов лет, то это всё равно
займет не меньше чем еще 

00:03:52.866,00:03:57.604
несколько триллионов лет, так
что это не настолько интригующе.
Так что, пожалуй, есть смысл сосредоточиться

00:03:57.604,00:04:02.843
на асимметричных реализациях,
где возможное ускорение с применением
квантовых вычислений может быть

00:04:02.843,00:04:08.949
огромным, и мы сейчас рассмотрим 
некоторые подробности того, почему
же ускорение оказывается именно

00:04:08.949,00:04:15.755
настолько велико и как это работает.
Давайте для начала немного освежим в памяти,
как именно работает шифрование RSA -

00:04:15.755,00:04:21.194
просто самые основы,
чтобы было на что опереться
для понимания того, как работают

00:04:21.194,00:04:26.199
квантовые версии этих алгоритмов.
Итак, я выбираю два простых
числа - p и q; 

00:04:28.201,00:04:33.907
перемножив их, я получаю 
число n. Теперь, используя 
полученное число n, я могу 

00:04:33.907,00:04:39.012
рассчитать лямбда-функцию -
если конкретнее, функцию Кармайкла,
которую я могу легко посчитать

00:04:39.012,00:04:44.818
и после этого я выбираю 
еще один параметр - e -
который меньше лямбды и 

00:04:44.818,00:04:51.558
значения функции. И затем это число
n в сочетании с числом e и будут
моим открытым ключом. Я могу поделиться

00:04:51.558,00:04:57.264
им с кем угодно, если хочу
заниматься с ним асимметричным
шифрованием. И я 

00:04:57.264,00:05:03.937
при этом владею также своим закрытым
ключом - числом d, которое
является просто инверсией по модулю

00:05:03.937,00:05:08.942
числа e, находящего в составе моего
открытого ключа. Очевидное mod
лямбда n. В этом сценарии у меня

00:05:13.380,00:05:19.286
всегда есть модуль лямбда n,
остающийся у меня закрытый ключ.
И с этим закрытым ключом

00:05:19.286,00:05:23.890
и пониманием сценария его создания
давайте теперь рассмотрим, как мне
теперь зашифровать что-либо и отправить,

00:05:23.890,00:05:30.864
гм, как послание от Алисы Бобу.
Как все понимают, с асимметричным 
шифрованием я могу только

00:05:30.864,00:05:35.869
зашифровать что-то, что меньше моего 
ключа, так что с ключом длиной 2048
я, очевидно, могу зашифровать

00:05:37.971,00:05:44.778
только что-нибудь, не превышающее 
по размеру 2048 бит. Так как мне
потребуется дополнять мой текст до

00:05:44.778,00:05:51.751
размеров числа n, я преобразовываю
это сообщение М в число m,
что можно сделать различными

00:05:51.751,00:05:55.455
способами. Не буду вдаваться
в излишние детали, но это тот момент,
когда используется схема дополнения

00:05:55.455,00:06:01.661
и затем в конечном счете
я наконец получаю результирующее число m.
В этом примере шифротекст создается

00:06:01.661,00:06:08.435
просто возведением этого числа m 
в степень e по модулю n...
получаем в итоге мой

00:06:08.435,00:06:13.440
шифртекст. Именно это я могу
теперь зашифровать открытым
ключом. Теперь я отправлю это число c

00:06:15.875,00:06:20.880
Бобу. Он получит его и, если
он располагает закрытым ключом,
то сможет спокойно расшифровать

00:06:23.016,00:06:28.588
полученное сообщение. В целом,
довольно прозрачная схема.
Все довольно-таки прямолинейно:

00:06:28.588,00:06:33.893
если кто-то владеет числом c и 
и шифротекстом, и 
закрытым ключом d... по определению

00:06:33.893,00:06:40.300
c - это m в степени e. So you
see the definition of d
was it is actually the inverse

00:06:40.300,00:06:45.305
of e so this e to the power of d
just equals out. В итоге я получаю
m по модулю n, так что, если у меня есть

00:06:47.607,00:06:53.580
закрытый ключ, я могу легко 
восстановить значение m 
и, очевидно, обратив

00:06:53.580,00:06:58.585
схему дополнения, я могу снова
получить исходное сообщение. Вот 
вкратце и все основные моменты того,

00:07:00.553,00:07:05.558
как работает RSA. Теперь рассмотрим такую
задачу: как, имея открытый ключ
(очевидно из названия, доступный всем),

00:07:08.495,00:07:13.933
получить из него закрытый. На словах
это действие может казаться


00:07:13.933,00:07:18.938
простым и тривиальным. Мне
необходимо подобрать те простые числа,
что в сумме дают число n. Это

00:07:22.342,00:07:29.049
число n является известной нам частью
открытого ключа. И если я смогу это
сделать, можно будет легко рассчитать

00:07:29.049,00:07:35.655
лямбда n - то есть, по факту,
наименьший общий множитель
лямбда p and лямбда q, откуда

00:07:35.655,00:07:40.660
я могу уже легко получить 
закрытый ключ d, и на этом дело в шляпе.
То есть все, что мне нужно сделать,

00:07:43.029,00:07:50.003
чтобы получить закрытый ключ из открытого,
это найти два простых делителя 
p и q, которые я выбрал еще

00:07:50.003,00:07:55.141
в самом начале при создании 
криптографических ключей, и тогда 
у меня будет достаточно данных

00:07:55.141,00:08:00.080
для того, что вычислить закрытый
ключ на основе открытого. Хотя
это звучит довольно легко и 

00:08:03.283,00:08:09.356
просто, на самом деле реализовать
это и разбить число n 
на простые множители p и q

00:08:09.356,00:08:15.595
невероятно сложно,
и все известные классические
классические алгоритмы для этого

00:08:15.595,00:08:21.334
имеют экспоненциальную сложность. Что
означает, что они крайне, крайне
сложны для расчета; даже, знаете,

00:08:21.334,00:08:26.773
алгоритмы GNFS только слегка 
эффективнее экспоненты, но
все еще весьма тяжелы. Это 

00:08:26.773,00:08:32.712
позволяет нам считать, что 
при использовании любых подобных
асимметричных алгоритмов для

00:08:32.712,00:08:39.185
их взлома потребовались бы триллионы лет,
что позволяло считать их вполне надежными
и для грядущих поколений. Но в

00:08:39.185,00:08:44.657
1984 году парень по имени Питер Шор,
физик-теоретик, 
придумал вот такой

00:08:44.657,00:08:51.297
алгоритм, рассчитанный на использование
квантовых компьютеров. Конечно,
в 1984 это было всего лишь теорией:

00:08:51.297,00:08:57.737
квантовые компьютеры еще не существовали
(да и сейчас-то едва существуют),
но на бумаге он изобрел

00:08:57.737,00:09:02.842
алгоритм, который позволял 
факторизовать эти числа за всего лишь 
полиномиальное время. Это совершенно

00:09:02.842,00:09:09.416
колоссальная разница 
по сравнению с экспоненциальным 
временем. То есть, по факту,

00:09:09.416,00:09:14.788
вместо того, чтобы использовать
классический компьютер и потратить
триллион лет по триллиону

00:09:14.788,00:09:19.459
операций в секунду, представим,
что у нас есть квантовый компьютер,
проводящий всего миллион операций

00:09:19.459,00:09:25.165
в секунду. И он может сделать то же 
самое за всего-то десять секунд.
Так что различие между

00:09:25.165,00:09:30.570
экспоненциальной и полиномиальной
сложностями алгоритмов
просто космическое, поэтому,

00:09:30.570,00:09:35.842
очевидно, если бы мы могли запустить 
этот алгоритм, это представляло 
бы большую угрозу практически любым

00:09:35.842,00:09:40.847
развернутым ныне криптосистемам,
так как они все основаны на асимметричном 
шифровании, будь то RSA или эллиптические

00:09:44.417,00:09:50.190
кривые, или цифровые
подписи ECDSA, используемые в bitcoin,
или протоколы обмена ключами вроде

00:09:50.190,00:09:55.195
протокола Диффи-Хеллмана, используемые
повсеместно в тех же SSL или TLS-соединениях,
так что можно сказать, что

00:09:57.197,00:10:01.835
это лежит в основе практически
всего современного интернета.
Это была бы чертовски масштабная

00:10:01.835,00:10:08.808
угроза. Теперь давайте немного
разберемся в том, как Питер Шор
пришел к придуманным им алгоритмам.

00:10:08.808,00:10:15.248
Что для них нужно и как они 
работают в реальной жизни. Сейчас
нам придется немного разобраться с тем,

00:10:15.248,00:10:21.187
как вообще работают квантовые
вычисления, и чем больше я об этом 
сейчас думаю, тем глубже мне, кажется,

00:10:21.187,00:10:26.759
придется погрузиться в эту тему, чтобы 
иметь возможность понять, как вообще
работает алгоритм Шора, 

00:10:26.759,00:10:31.798
так что, надеюсь, это 
не будет чересчур для вас. В общем,
сейчас существует два основных

00:10:31.798,00:10:37.604
типа квантовых компьютеров. Первый - это 
компьютеры на основе квантовых вентилей.
Это заметная доля от того,

00:10:37.604,00:10:42.909
над чем сейчас все работают. Все 
большие шишки вроде IBM, Intel,
Microsoft, Alibaba заняты

00:10:42.909,00:10:47.714
именно компьютерами на квантовых
вентилях, которые еще называют
универсальными квантовыми компьютерами,

00:10:47.714,00:10:52.452
поскольку они должны быть способны
решать практически любые задачи, 
подобно классическим

00:10:52.452,00:10:58.958
компьютерам. Другой возможный подход - 
это так называемый "квантовый отжиг",
или адиабатические квантовые

00:10:58.958,00:11:03.997
вычисления - таким был первый
рабочий квантовый компьютер,
созданный проектом D-wave. И

00:11:03.997,00:11:09.002
компьютер D-wave - это именно
адиабатический, а не универсальный
квантовый компьютер. Вы 

00:11:09.002,00:11:15.008
не можете решать произвольные
задачи с его использованием;
он заточен исключительно на 

00:11:15.008,00:11:21.447
определенные задачи оптимизации.
По большей части можно 
рассматривать его как 

00:11:21.447,00:11:27.186
физическую систему; как и любая такая
система, она стремится к наименьшему 
возможному энергетическому уровню,

00:11:27.186,00:11:34.060
которое мы называем основным состоянием
системы. Итак, если мы определим функцию,
которую я хочу вычислить,

00:11:34.060,00:11:39.065
и определим таким образом,
что наименьшее энергетическое состояние
системы будет соответствовать

00:11:42.001,00:11:48.207
решению задачи оптимизации,
то можно будет воспользоваться
этой системой для ее решения,

00:11:48.207,00:11:52.812
потому что мы знаем, что конечным
состоянием этой физической системы
будет наименьшее по энергетическому

00:11:52.812,00:11:59.252
уровню - основное состояние. And I
know then this also tends this
also represents the state when

00:11:59.252,00:12:05.525
my optimization problem reaches
the lowest state. А еще есть 
вот это весьма клевая теорема,

00:12:05.525,00:12:10.997
которая гарантирует, что 
мы в итоге действительно окажемся в 
наименьшем возможном состоянии. Можно

00:12:10.997,00:12:15.568
представить это метафорически в виде
гор и низин. Спускаясь, ты можешь
оказаться в низине, которая будет

00:12:15.568,00:12:20.640
только на полпути вниз,
не являясь наиболее низкой возможной точкой.
Но по этой теореме мы

00:12:20.640,00:12:23.977
are gonna explore that’s a
little bit which guarantees
which gives me a way how we can

00:12:23.977,00:12:29.215
really be at the lowest state so
we can solve or I can find the
optimsolution to this

00:12:29.215,00:12:34.053
optimization problem. But it is
really just solving optimization
problems. The gate based quantum

00:12:34.053,00:12:40.426
computing is really a general
quantgeneral computing um
architecture where you start

00:12:40.426,00:12:45.898
with an input. You apply all
sorts of different calculations
to it. Technically these are all

00:12:45.898,00:12:50.970
gate based calculations. You do
an end gate. Вы берете два кубита,
делаете что-то с ними и получаете

00:12:50.970,00:12:55.642
результат. В общем-то, подаете
что-то на вход, проводите вычисления
и получаете что-то на выходе. И 

00:12:55.642,00:13:00.380
в целом вы можете рассчитать
практически что угодно
с помощью таких вот

00:13:00.380,00:13:07.186
универсальных квантовых компьютеров,
в то время как D-wave и его
аналоги могут решать только

00:13:07.186,00:13:12.792
задачи на оптимизацию. Но 
на самом деле, как оказалось,
оба подхода вполне применимы

00:13:12.792,00:13:17.797
для решения задачи факторизации.
И у нас есть алгоритм Шора от 1994
года, который использует для этого

00:13:22.001,00:13:26.606
именно гейты. И у нас в 
QuantAnnealing с 2002 года
испытывались различные подходы,

00:13:26.606,00:13:31.110
я расскажу немного подробнее 
на нескольких следующих слайдах
о них и о том, как именно они

00:13:31.110,00:13:37.350
помогают нам в решении задачи
факторизации в формате задачи
оптимизации. Итак, гм,

00:13:37.350,00:13:43.089
давайте немного углубимся в
вопросы квантовых вычислений и того,
что необходимо понимать для

00:13:43.089,00:13:48.695
разбора алгоритмов Шора;
также хотелось бы донести до вас
общее понимание того,

00:13:48.695,00:13:55.334
как вообще кому-то удалось вывести
алгоритм, дающий настолько
весомое улучшение по сравнению с 

00:13:55.334,00:14:00.273
классическим алгоритмом и его 
экспоненциальной сложностью расчетов.
Итак, основными строительными блоками

00:14:03.409,00:14:08.815
для квантовых компьютеров являются
так называемые кубиты. Кубит - это
эквивалент классического бита.

00:14:08.815,00:14:15.321
Классический бит всегда равен нулю
или единице. Кубит в первом приближении
представляет собой квантомеханическую

00:14:15.321,00:14:20.660
систему которая может находиться
в любом нужном вам состоянии.
И вы на самом деле не знаете,

00:14:20.660,00:14:25.765
в каком состоянии она находится.
Но стоит вам провести акт измерения
ее состояния, и вы получите

00:14:25.765,00:14:30.970
ноль либо единицу. А это то,
что нам стоит рассмотреть 
позднее более подробно, потому что

00:14:30.970,00:14:36.676
это причина того, что до акта измерения
системы мы не знаем ее состояния,
и фактически она может пребывать

00:14:36.676,00:14:43.583
в суперпозиции. Она может находиться
в состоянии, при котором все эти кубиты
могут взаимодействовать друг

00:14:43.583,00:14:49.455
с другом, и только в самом конце
моего шага обработки я измеряю
статус системы, и все 

00:14:49.455,00:14:54.527
это состояния суперпозиции 
схлопнутся, и я получу
в итоге ноль или единицу. Но

00:14:54.527,00:14:58.931
на самом деле, так как система 
подчиняется законам квантовой
механики, ее состояние и не ноль,

00:14:58.931,00:15:03.870
и не единица. Это что-то
среднее между ними. Довольно часто
мы затем присваиваем им переменные,

00:15:06.672,00:15:11.010
и здесь вы можете увидеть представление
одного из этих кубитов.
У нас есть два основания: 

00:15:11.010,00:15:16.015
ноль и единица; здесь 
ноль на самом деле означает,
что при измерении состояния кубитов

00:15:19.652,00:15:25.057
в ста процентах случаев
результатом будет 
ноль. Единица же означает,

00:15:25.057,00:15:29.195
что в ста процентах случаев
результатом измерений
будет единица. И в итоге

00:15:29.195,00:15:34.834
кубит находится в  суперпозиции 
этих двух основных состояний
с вероятностями альфа и бета.

00:15:34.834,00:15:41.240
С помощью двух комплексных чисел
мы теперь можем представить
состояние этого конкретного

00:15:41.240,00:15:47.580
кубита. Назовём альфа и
бета амплитудами вероятности,
поскольку, если я измерю этот

00:15:47.580,00:15:52.585
конкретный кубит, 
я получу
исход измерения

00:15:56.489,00:16:01.460
с нулём с вероятностью 
альфа в квадрате; 
аналогично, для

00:16:01.460,00:16:06.265
вероятности получить результат
измерения с единицей
значение будет равно бета в квадрате

00:16:06.265,00:16:09.535
Заметьте, что когда я провожу измерение
конкретного кубита, хотя он и представлен 
двумя комплексными числами,

00:16:09.535,00:16:15.975
но результатом все равно будет
или ноль, или единица - с определенной
вероятностью - и эти вероятности

00:16:15.975,00:16:21.047
фактически определяются
этими двумя числами -
то есть, фактически,

00:16:21.047,00:16:26.052
альфа и бета в квадрате.
we know right now is going to
end up in zero and with those

00:16:28.120,00:16:33.392
two numbers I can represent
those qubits it's basically a
mathematical representation of

00:16:33.392,00:16:39.398
the quantmechanical system uh
that the quantcomputers are
operating. Но не стоит забывать,

00:16:39.398,00:16:43.302
что все эти измерения,
как и вообще что угодно 
в квантовом мире, вероятностно.

00:16:43.302,00:16:50.009
Все - только вероятности.
Я могу поместить фотон в состояние,
в котором точно можно будет сказать,

00:16:50.009,00:16:53.946
что половина измерений дадут
ноль, а половина результатов
будет единицей.

00:16:53.946,00:16:57.583
Это, например, идеально 
подходит для создания случайных
чисел, потому что, поверьте,

00:16:57.583,00:17:01.454
вы действительно не знаете
заранее, каким будет результат .
Шанс получить ноль и единицы один,

00:17:01.454,00:17:06.392
так что достаточно одного кубита.
Измерьте его пять триллионов раз,
и получите пять триллионов

00:17:06.392,00:17:11.430
случайных битов. But obviously I don’t
really know whether I get zero
or one. Все решают

00:17:11.430,00:17:16.502
вероятности. Это сильно влияет
на алгоритмы, поскольку они
тоже будут выдавать

00:17:16.502,00:17:21.774
мне лишь вероятности.
Нет алгоритма, который 
после одного прогона

00:17:21.774,00:17:27.780
скажет мне с уверенностью
"да, ответ будет вот таким".
Нет, мы получим "Ну, знаешь,

00:17:27.780,00:17:31.884
процентов на 83 я уверен,
что ответ будет во-о-от такой",
например. Так что 

00:17:31.884,00:17:36.889
довольно часто вам придется
делать несколько прогонов таких
алгоритмов, чтобы получить

00:17:36.889,00:17:42.995
нужный вам результат. Второй ключевой
момент, который нужен нам для понимания 
алгоритма Шора - это концепция

00:17:42.995,00:17:48.801
запутанности, и здесь мы слегка 
съезжаем на философские рельсы.
Я бы хотел немного задержаться

00:17:48.801,00:17:53.639
здесь на математической стороне вопроса.
По сути, запутанность - это свойство,
при котором два имеющихся у меня

00:17:53.639,00:17:58.678
кубита имеют между собой некоторую
известную мне корреляцию.
В классическом мире

00:17:58.678,00:18:02.181
у меня есть два бита, которые 
всегда будут полностью независимы
друг от друга.

00:18:02.181,00:18:05.751
Ни один из них не будет действовать
на другой, и если один 
из них имеет значение "единица",

00:18:05.751,00:18:07.753
значение второго вообще не важно.
В квантовом же мире мои кубиты
могут иметь некоторую взаимосвязь

00:18:07.753,00:18:09.755
между ними. Простейшим примером
будет состояние Белла
для двух кубитов. Это состояние,

00:18:09.755,00:18:14.760
в котором у нас имеются два кубита.
В этих забавных закорючках
первый ноль - это значение

00:18:26.272,00:18:30.977
первого кубита. Второй ноль - 
соответственно, значение второго
кубита. Но если мы измерим значение

00:18:30.977,00:18:37.249
первого кубита и получим  
в результате, например, ноль,
то значение второго никак не может

00:18:37.249,00:18:43.422
отличаться, поскольку мы уже знаем,
что первый кубит равен нулю. Так что
второй кубит тоже должен быть равен

00:18:43.422,00:18:48.627
нулю. Я узнаю значение второго кубита
просто потому, что я 
перед этим уже измерил первый.

00:18:48.627,00:18:54.000
Иначе быть не может:
в схеме нет вариантов "один - ноль"
или "ноль-один", поэтому

00:18:54.000,00:18:59.905
второй кубит не может получить
отличное от нуля значение. So I take
basically two qubits. Give them

00:18:59.905,00:19:04.677
into this quantmechanical
system. Введем их в состояние Белла,
и теперь у нас есть два кубита,

00:19:04.677,00:19:10.249
отделенных друг от друга,
но связанных в рамках этой 
квантовомеханической системы -

00:19:10.249,00:19:16.255
или, пользуясь терминологией,
спутанных. Теперь мы можем дать 
один кубит Алисе и отправить ее

00:19:16.255,00:19:21.260
на Луну, а другой отдать Бобу
и направить его на Марс. Теперь
я уверен, что если Алиса посмотрит

00:19:23.496,00:19:30.403
на свой кубит и скажет "о, а у меня-то
ноль", то Боб тоже получит ноль.
Хотя эти двое не взаимодействовали,

00:19:30.403,00:19:35.674
но за счет существующей 
корреляции характеристики их 
кубитов теперь связаны.

00:19:35.674,00:19:40.479
Итак, я могу просто взять два
кубита, подготовить их заранее,
после чего их можно будет отправить

00:19:40.479,00:19:46.819
туда, куда захочется, и они 
останутся связаны 
без всякого прямого взаимодействия 

00:19:46.819,00:19:52.858
между ними. Это влечет за собой
множество довольно философских 
последствий. Например, если я

00:19:52.858,00:19:58.731
разнесу эти два кубита на многие
световые годы друг от друга.
Даёт ли это мне возможность передавать

00:19:58.731,00:20:04.003
информацию быстрее скорости света? 
Нет, поскольку Алиса,
получив в результате измерения ноль,

00:20:04.003,00:20:08.240
сможет сообщить Бобу об этом,
только отправив ему сообщение
обычным образом,

00:20:08.240,00:20:14.213
и сообщение будет идти
в течение нескольких лет.
Тем не менее, это важный

00:20:14.213,00:20:19.719
принцип, который будет в том числе
использован в алгоритме Шора. 
И еще одна ключевая вещь, которую

00:20:19.719,00:20:26.358
нужно понимать, если имеешь
дело с квантовыми системами - это
экспоненциальные масштабы.

00:20:26.358,00:20:31.764
Предположим, у меня есть два
обычных бита. Я могу представить
четыре возможных состояния

00:20:31.764,00:20:37.570
с их помощью, но только одно 
из них за раз. so y’know if uh
you see the four states there.

00:20:37.570,00:20:43.175
Моя система из этих двух битов
всегда пребывает в одном из этих
состояний в каждый момент времени.

00:20:43.175,00:20:48.914
В квантовом мире я могу использовать
два кубита 
when I measure this system it’s

00:20:48.914,00:20:53.385
also gonna be in one of those
four states. Но до измерения
состояния системы она 

00:20:53.385,00:20:58.390
благодаря суперпозиции этих кубитов
может пребывать во всех четырех состояниях
одновременно, и только в момент

00:21:00.960,00:21:06.999
измерения состояния система 
схлопнется в одно из этих четырех
состояний. And this is exactly now

00:21:06.999,00:21:12.905
a situation we are gonna explore
it. С помощью n кубитов я могу 
представить два в степени n

00:21:12.905,00:21:18.811
состояний в ходе вычислений; однако,
в конце концов мне понадобится 
все же узнать результат 

00:21:18.811,00:21:24.550
моих расчетов, так что в определенный 
момент я проведу измерение,
и это схлопнет систему в одно

00:21:24.550,00:21:29.989
из этих конечных состояний;
но пока расчеты идут, у меня
есть два в степени n состояний,

00:21:29.989,00:21:35.327
что весьма немало, 
и я могу представить их с помощью
всего лишь небольшого числа

00:21:35.327,00:21:40.332
кубитов. Итак, теперь у меня есть
весь арсенал для того, чтобы
рассмотреть алгоритм Шора и 

00:21:42.434,00:21:47.439
как он работает. Давайте перейдем
к этому. Итак, главной идеей,
которая пришла в голову Шору, было

00:21:47.439,00:21:52.478
то, что если мне необходимо
найти способ разложить число N 
на простые множители p и q, то

00:21:52.478,00:21:57.550
на самом деле мне не обязательно 
решать эту задачу в лоб: она 
фактически эквивалентна

00:21:57.550,00:22:04.123
другой задаче. Он начал исследовать тему
числовых последовательностей и благодаря
теории чисел он кое-что понял. Если

00:22:04.123,00:22:10.029
у вас есть последовательность чисел...
Например, посмотрите вот на эту:
все довольно просто,

00:22:10.029,00:22:17.036
просто умножаем предыдущее число 
на два. Получаем 1, 2, 4, 8, 16,
32. Теперь возьмем производную 

00:22:17.036,00:22:23.509
от данной последовательность, 
в данном примере - берём остаток
по модулю 15. Получаем 

00:22:23.509,00:22:29.181
последовательность 1, 2, 4, 8, 1,
2, 4, 8, 1, 2, 4, 8. Это то,
что мы назовем периодической

00:22:29.181,00:22:35.487
последовательностью, потому что она состоит из
одних и тех же повторяющихся раз за разом
чисел 1, 2, 4, 8.

00:22:35.487,00:22:42.361
Теперь мы можем определить период
этой последовательности, то есть 
число элементов,

00:22:42.361,00:22:49.168
через которое последовательность 
начинает повторяться.
Итак, под капотом

00:22:49.168,00:22:56.141
алгоритма Шора лежит следующее:
если я хочу найти подходящие простые
множители числа N - 

00:22:56.141,00:23:02.748
числа p и q, я на самом деле могу
преобразовать это в задачу
поиска периода R и, как оказалось,

00:23:02.748,00:23:09.355
эта именно тот тип задач,
которые прекрасно подходят для
квантовых компьютеров. Так что,

00:23:09.355,00:23:13.792
I look into this and the cool
thing is and и на следующем слайде
я покажу вам

00:23:13.792,00:23:18.530
математику, стоящую за этим,
в основном сводящуюся к весьма
тривиальным основам линейной алгебры,

00:23:18.530,00:23:22.434
которых будет достаточно для понимания
того, как все это работает. 
Основное, что вам нужно учитывать,

00:23:22.434,00:23:26.272
это что в рамках 
теории чисел есть 
теорема, которая утверждает?

00:23:26.272,00:23:31.277
что функция f(a), равная остатку 
от x в степени a по модулю N,
является периодической при

00:23:34.580,00:23:39.585
свойствах x, и теперь мне нужно
только найти значение 
периода R, с которым мы

00:23:42.121,00:23:46.258
можем перейти к алгоритму Шора,
который содержит много
особенностей на квантовом уровне,

00:23:46.258,00:23:52.097
но в целом сводится к трем фазам.
Сначала я заменяю задачу разложения
на множители задачей поиска периода,

00:23:52.097,00:23:57.102
и это довольно тривиально.
Затем я использую квантовый компьютер
для поиска значения R;

00:23:59.405,00:24:04.410
для классических компьютеров
эта задача все еще 
очень, очень трудна,

00:24:04.410,00:24:10.282
так как представляет 
экспоненциальную сложность,
так что такая замена задачи

00:24:10.282,00:24:16.689
на классическом компьютере не 
даст мне никакого преимущества. Но
я могу воспользоваться квантовым

00:24:16.689,00:24:21.160
преобразованием Фурье, и это 
даст мне желаемое ускорение
и поможет рассчитать период R.

00:24:21.160,00:24:27.099
Из него можно уже легко получить
множители, так что первый и третий
шаги можно считать 

00:24:27.099,00:24:30.836
весьма тривиальными. Вся магия 
происходит именно на втором шаге, 
и именно за счет него мы получаем

00:24:30.836,00:24:37.609
основное ускорение. Не хочу вдаваться
в излишние подробности, но
там нет ничего сложного, так что,

00:24:37.609,00:24:44.049
если хотите, можете просто 
скачать слайды и просмотреть их.
Я знаю, что f(a) - периодическая.

00:24:44.049,00:24:49.188
Я знаю, что что x в степени ноль -
это единица. То есть любое число
в степени ноль будет единицей. И если

00:24:49.188,00:24:55.661
мой период равен R, то раз функция
периодическая, то остаток
x в степени r по модулю n

00:24:55.661,00:24:59.965
тоже равен единице. Equals the same
what it was before because is
one period. И, как подсказывают мне

00:24:59.965,00:25:04.203
основы линейной алгебры, мы можем 
записать, что x в степени r равняется 
x в степени r пополам

00:25:04.203,00:25:09.208
в квадрате. И теперь я могу
просто переписать это уравнение
в другой форме: получаем, что

00:25:13.846,00:25:18.851
это произведение двух чисел
дает мне ноль по модулю N.
Так что если я использую

00:25:23.322,00:25:28.327
это R I ha- I have these
two numbers so but if those two
numbers mod N is uh

00:25:31.397,00:25:37.903
не являются целыми множителями
N because their
product is zero mod n so that

00:25:37.903,00:25:44.109
means that they’re integers
multiple of n so either those
are directly factors or if they

00:25:44.109,00:25:50.616
are not directly factors each
one of those has a factor in
common with a number I want to

00:25:50.616,00:25:56.588
look at. Наибольший 
общий делитель не так уж 
сложно найти с помощью обычного

00:25:56.588,00:26:01.693
компьютера, сложность здесь
всего лишь n в квадрате, так что 
нахождение наибольшего общего

00:26:01.693,00:26:06.698
делителя для каждого из этих чисел
numbers with n I have my factors
for for n and that is

00:26:09.001,00:26:14.873
really simple. Но вот найти 
это самое R очень, очень тяжело.
Но мы можем разобраться на 

00:26:14.873,00:26:19.878
одном весьма простом примере.
Предположим, наше N равно 15. Любой
может мгновенно сообразить, что 

00:26:19.878,00:26:24.883
его простыми делителями
будут 3 и 5. Теперь я выбираю любое
целое число от 1 до 15;

00:26:27.352,00:26:33.725
давайте для простоты решим,
что мы используем x, равное
двум. Как вы видите, период

00:26:33.725,00:26:39.698
по модулю 15... так: 1, 2, 4, 8 - 
значит, период равен 4. 
Теперь начинается самая сложная

00:26:39.698,00:26:44.703
для расчетов часть. Но с периодом 4
наибольший общий делитель 
x в степени R пополам -

00:26:47.306,00:26:52.311
это четыре, так что R пополам равен двум.
X=2, так что мы возводим двойку
во вторую степень и получаем четыре.

00:26:54.913,00:27:01.086
Так что наибольший общий делитель
3 и 15 и 5 и 15, так что
четыре минус один и четыре

00:27:01.086,00:27:05.858
плюс один - очевидно, 3 и 5.
And when you calculate the
through action in every case you

00:27:05.858,00:27:11.129
come up with 3 and 5. 
Алгоритм Шора весь об этом.
Но действительно

00:27:11.129,00:27:16.301
сложная часть - это поиск
значения периода R,
и тут на сцену выходят 

00:27:16.301,00:27:21.373
квантовые алгоритмы.
И эти компьютеры... эти 
квантовые алгоритмы

00:27:21.373,00:27:26.378
всегда работают на одних и 
тех же принципах. You basically
you инициализируете тот результат,

00:27:28.514,00:27:33.519
что хотите увидеть:
мы прикидываем, ожидаем ли увидеть 
256-битное или 2048-битное число,

00:27:35.988,00:27:40.659
number and you basically every
bit every bit of this bit
recommendation is either gonna

00:27:40.659,00:27:45.464
be zero or one. So you basically
put this in an equal uh
superposition so every bit you

00:27:45.464,00:27:48.700
basically put at fifty percent
zero and fifty percent one
because you really don’t know

00:27:48.700,00:27:54.473
what it is. So it’s really kind
of like at fifty percent.
Then you run through this

00:27:54.473,00:28:00.913
QuantFourier transform which
will use amplitude amplification
so with every duration of this

00:28:00.913,00:28:05.918
algorithm those amplitudes will
go toeither one or to zero which
is gonna be the final result.

00:28:08.253,00:28:14.459
And you run this through a
number of times and then you
measure it at the end and you

00:28:14.459,00:28:20.065
will see when you end up with.
I’m gonna have an example of
this when we run this through

00:28:20.065,00:28:25.571
on a on real quantcomputer.
So just to summarize.
Shor’s algorithm altogether is

00:28:25.571,00:28:31.176
fairly simple. You choose any
random number a which is uh
smaller than N. You compute the

00:28:31.176,00:28:35.814
greatest common divisor. If this
is not one. Actually you found a
you found a factor and then you

00:28:35.814,00:28:41.153
are done. But that is uh
obviously most likely not the
case. I use my quantcomputer

00:28:41.153,00:28:46.692
to find this period R and once I
have R I just need to find the
greatest common divisor of those

00:28:46.692,00:28:51.697
two two terms and I’m
done. So another example I
choose randomly number seven.

00:28:54.900,00:28:59.905
Calculate period r, R equals 4.
I have the greatest common
divisor 48 and 15 and 50 and 15

00:29:02.374,00:29:07.379
gives me 3 and 5 so it all
works fine. I can now use this
and use a livbrayr a

00:29:10.549,00:29:16.355
toolkit called Qiskit which is
an open source toolkit there’s
now at least 5 or 6 open source

00:29:16.355,00:29:21.593
platforms how you can use
quantcomputers and how you
can program quantcomputers um

00:29:21.593,00:29:27.599
either on quantsimulators or
on real quanthardware. And i
gave you some references here

00:29:27.599,00:29:32.604
you can look at those it's
actually kind of fairly easy um
to go through. But they also

00:29:32.604,00:29:37.109
have the same and here’s an
example of this amplitude
amplification. Basically in the

00:29:37.109,00:29:42.581
end you see all of the
possibilities what the my prime
numbers could be. They all in

00:29:42.581,00:29:47.819
the same probability of what
they could be. That’s my
starting point. And once I run

00:29:47.819,00:29:53.925
through this algorithm and I ran
through this Shor’s algorithm
on from these references. The

00:29:53.925,00:29:59.898
amplitude of the correct results
have now been amplified and the
amplitudes of the wrong results

00:29:59.898,00:30:05.337
have now been kind of like gone
down to zero. And I actually see
that these two results R equals

00:30:05.337,00:30:08.006
0 and R equals 4. R equals zero
is obviously trivial uh
probability so I discard this

00:30:08.006,00:30:13.011
and I end up with R equals 4. So
this was now executed on a
quantsimulator. Quantum

00:30:17.482,00:30:21.787
simulator I can simulate a
quantstate on my normal
computer. But remember in

00:30:21.787,00:30:26.391
quantcomputing we exploiting
this fact that I have this
massive large space of 2 to the

00:30:26.391,00:30:32.197
power of N so I’m gonna really
travel simulate more than
hundred qubits or so on a normal

00:30:32.197,00:30:37.269
computer and but for
smaller ones for
demonstrations it is actually

00:30:37.269,00:30:43.442
quite cool. So the cool thing is
IBM has a quantcomputer that
you can publicly access you can

00:30:43.442,00:30:49.514
write a a quantcomputer
program executed towards their
cloud. It's very simple you just

00:30:49.514,00:30:55.320
change hey my backend is the
simulator you change the backend
to IBMs quantcomputer. Um

00:30:55.320,00:31:00.025
and if you execute this against
a real quantcomputer. It is
just a 5 qubit quantcomputer

00:31:00.025,00:31:05.964
right now. I still get R
equals 4 with the highest
probability. But you see there's

00:31:05.964,00:31:11.369
lots of other probabilities and
those probabilities are
representative of all the errors

00:31:11.369,00:31:15.874
you have in the system simply
because those quantcomputers
that we have right now are

00:31:15.874,00:31:20.879
really pretty bad. What they are
what we call noisy. They don’t
produce the correct result.

00:31:22.948,00:31:28.353
Because they’re noisy they
produce lots of wrong results.
Now repeat- by repeating my

00:31:28.353,00:31:33.892
algorithms lots of times I can
still get around this fact and
obviously in this case I still

00:31:33.892,00:31:38.130
have R equals 4 the highest
probability. But obviously that
has big implication of

00:31:38.130,00:31:43.101
performance because I need to
now repeat these these
algorithms much more and

00:31:43.101,00:31:49.307
obviously I will end up in debt
cases because obviously the
noise will basically uh

00:31:49.307,00:31:55.480
reduce the speedup in the
quanteffects to zero and it
basically collapses to a

00:31:55.480,00:32:00.418
a classical computation that
I have. But the cool is actually
with Qiskit as well there there

00:32:02.954,00:32:07.893
is libraries for every quantum
algorithm that y’know that
people know and they kind of uh

00:32:07.893,00:32:12.998
provide these libraries. If you
wanna run Shor’s algorithm to
factor a prime to factor any

00:32:12.998,00:32:19.070
numbers. You just import Shor’s
algorithm from Qiskit aqua which
is a which is a library. You

00:32:19.070,00:32:24.442
just say alright I want to
factor this number N equals 15.
I use a simulator. I do this uh

00:32:24.442,00:32:31.016
1,000 times and off I run.
It’s instant and I get a result.
How cool is this that you can

00:32:31.016,00:32:34.619
run this run this against a-
against a Quantcomputer and
the only thing you need to do in

00:32:34.619,00:32:39.024
this example is if you run this
against real quantcomputer is
you change the backend from the

00:32:39.024,00:32:44.830
simulator to a different backend
and now there’s a callout to
IBMs quantcomputer to run

00:32:44.830,00:32:49.935
this on their backend. It's
actually really really cool and
this feeling when you run a

00:32:49.935,00:32:55.440
quantcomputing software for
the first time is actually quite
cool. So I encourage everybody

00:32:55.440,00:33:01.446
to look at Qiskit or various
quantcomputer libraries and
to play around with this. So the

00:33:01.446,00:33:07.319
problem obviously is and you
guessed it is in order to do
anything meaningful I need lots

00:33:07.319,00:33:12.557
of qubits. So in order to use uh
Shor’s algorithm to to
break RSA 2048 I need 4,000

00:33:12.557,00:33:14.626
qubits and I need 4,000 proper
qubits meaning without any
noise. I need for the time of

00:33:14.626,00:33:19.631
the computation there can’t be
any noise on the computation as
well. And it's not really a

00:33:26.538,00:33:31.409
surprise because when Shor came
up with this in 1984 there
weren’t any quantcomputers.

00:33:31.409,00:33:35.747
He didn’t have to worry about
hey can I really implement my
algorithm or not. He really just

00:33:35.747,00:33:40.785
came up with this system and
method. So it was never
really meant to run on a quantum

00:33:40.785,00:33:42.787
computer and right now lots
of people look at Shor’s
algorithm and they say alright

00:33:42.787,00:33:45.991
kind of right now we have 70
qubit so its every the qubit
count doubles every year

00:33:45.991,00:33:47.993
whatever so it's gonna be
another ten years before we
have Shor’s algorithm. Nobody’s

00:33:47.993,00:33:50.929
gonna run Shor’s algorithm
because it was just a theory. So
let’s look at some of the-the uh

00:33:50.929,00:33:53.765
research where people took
people took Shor’s algorithm and
modified them and optimized them

00:33:53.765,00:33:56.601
to run on real quantuh
quanthardware. So the first
one was Fowler in in 2012.

00:33:56.601,00:33:59.838
Basically the first approach was
really kind of I need to tweak
this algorithm so it can be so

00:33:59.838,00:34:04.776
it can sustain errors. Because
Shor’s Algorithm was really
under the assumption there’s no

00:34:12.017,00:34:17.022
errors or the qubits are
fantastic no errors so
basically they used what is

00:34:27.799,00:34:34.239
called the surface codes to
allow for errors to occur and
the error rate is 0.1 percent of

00:34:34.239,00:34:40.812
the of the gate error rate
and Fowler came up I can
run Shor’s algorithm and I can

00:34:40.812,00:34:47.218
factor 2048 bit number but I
need one billion qubits to do so
which is obviously a massive

00:34:47.218,00:34:53.491
amount in terms of over it um
to run this. So that was in
2012. Not to long a- not too

00:34:53.491,00:34:59.998
long ago. And then in 2017 with
further optimization from O’
Gorman we suddenly kind of like

00:34:59.998,00:35:04.936
had had an algorithm where it
reduces one billion qubits to
230 million qubits in 2017.

00:35:09.274,00:35:13.411
And that’s really an
optimization the physical
connectivity of those qubits.

00:35:13.411,00:35:18.483
And then Gheorghiu kind of
reduces further to 170 million
qubits so you can see there’s

00:35:18.483,00:35:23.955
algorithmic improvement without
any hardware improvements
obviously that’s happening at

00:35:23.955,00:35:28.426
the same time as well but
obviously I get down from 1
billion qubits to right now 170

00:35:28.426,00:35:34.899
million qubits. And the biggest
contribution was from
Gidney and Ekera from uh

00:35:34.899,00:35:40.872
Google and University in
Stockholm where they provided
paper just not long ago earlier

00:35:40.872,00:35:46.211
this year where they looked
into how they could do the same
thing that everyone else is

00:35:46.211,00:35:51.216
doing with just 20 million
qubits. Now we went in 2012 with
1 billion qubits to 2019 to 20

00:35:53.685,00:35:59.658
million qubits and we are far
from the end of the research
there in terms of optimization

00:35:59.658,00:36:06.131
to this problem. Now I won’t
go into too much detail of this
of what they do but

00:36:06.131,00:36:11.102
basically they also look into
lots of optimization of how
things work. And that basically

00:36:11.102,00:36:16.107
also similar to Shor not really
look into factoring the numbers
directly so that basically

00:36:18.710,00:36:23.982
convert this factoring problem
into Shor Discreet Algorithm uh
problem and they have a

00:36:23.982,00:36:30.855
part that is computed
classically and a part that is
computed quantumly on a

00:36:30.855,00:36:37.629
quantcomputer. And they can
show that in order to find p and
q they can come up with

00:36:37.629,00:36:43.234
obviously they know what n is
which is the multiplication
of those two. They can come up

00:36:43.234,00:36:47.472
with a number where they know
that the addition of these
numbers is these or these known.

00:36:47.472,00:36:53.344
Sol if they have two uh
equations for two variables
which they can fairly easily

00:36:53.344,00:36:56.781
solve fairly easily is obviously
an overstatement because they
still need 20 million uh

00:36:56.781,00:37:03.655
qubits to do so. but
obviously the the um
reduction from 1 billion qubits

00:37:03.655,00:37:08.193
to 20 million qubits is uh
massive and I expect in the
next couple of years there’s

00:37:08.193,00:37:12.931
gonna be lots of optimization
through Shor’s algorithm and
especially to Gidney and Ekera’s

00:37:12.931,00:37:19.304
algorithm where this is
gonna be reduced further
on. Obvuiously 20 million qubits

00:37:19.304,00:37:25.610
is still a long way away from uh
quantcomputers that are
accessible today where we

00:37:25.610,00:37:30.615
are in the realm of slowly below
100 qubits at this point
in time. So I want to spend the

00:37:32.951,00:37:36.855
next you know or the last ten
minutes of my presentation on
the process of quantum

00:37:36.855,00:37:42.026
annealing. This is the second
type of quantcomputer and uh
that is actually what is quite

00:37:42.026,00:37:45.797
surprising to me even though
everyone is talking about Shor
and the implication of

00:37:45.797,00:37:50.935
cryp-cryptography. Actually
quantannealing right now is
much much further ahead in terms

00:37:50.935,00:37:55.406
of solving this factorization
problem. And we are going to
look into a little bit how uh

00:37:55.406,00:38:00.378
these algorithms work. So as
mentioned before quantum
annealing those computers are

00:38:00.378,00:38:05.049
really computes where it can
solve optimization problem. I
need to I need to define my

00:38:05.049,00:38:09.788
problem as an optimization
problem and then basically
quantannealing computer can

00:38:09.788,00:38:16.060
take this problem and then find
minimof this problem
because it represents a physical

00:38:16.060,00:38:20.732
state and I know the physical
state will always end up in the
ground state and I can read in

00:38:20.732,00:38:25.003
this ground state and I will
have the solution to my problem.
And there is really a cool a

00:38:25.003,00:38:31.976
cool theorem where you’re
gonna find you wanna go into the
lowest point. You wanna find

00:38:31.976,00:38:36.047
this lowest point on the right
hand side. So how do we find
this lowest point and not get

00:38:36.047,00:38:41.920
caught up in those minimums
in between. And there’s lots
of ways how you can do this from

00:38:41.920,00:38:47.992
the from the physical system.
And there’s really cool case on
this quantannealing case

00:38:47.992,00:38:52.997
where there is a theorem that
says if I start in a really in a
very easy quantmechanical

00:38:55.500,00:39:01.506
system. In this really easy
quantmechanical system I know
the ground state. So this is my

00:39:01.506,00:39:06.711
problem I want to solve is here.
I am starting here and I really
know where I am. I can now

00:39:06.711,00:39:13.384
slowly evolve and adiabatic
means slowly evolving this state
from this here to the state

00:39:13.384,00:39:19.958
where I really wanna be and now
this theory gives me a guarantee
or physical proof that I will

00:39:19.958,00:39:26.231
end up in the in the maximin
the optimal minimof the
problem that I wanna solve. And

00:39:26.231,00:39:31.502
it’s really cool so I have
Hamiltonians or functions that
define a physical system but

00:39:31.502,00:39:36.174
basically if you look at the
first function if you put in s
equal zero you end up in this

00:39:36.174,00:39:41.179
high H zero which is my easy to
understand system where I know
the local minimand in my

00:39:43.214,00:39:49.454
calculation I slowly moves from
zero to one and if I am at one I
am in the stage high H one which

00:39:49.454,00:39:54.859
is the problem that I really
want to solve. But this uh
adiabatic theorem guarantees to

00:39:54.859,00:40:00.598
me that I will end up in the
maximminimfor the problem
that I really want to solve.

00:40:00.598,00:40:05.403
Which is really really cool
because it gives I know I’m
not going to be caught in some

00:40:05.403,00:40:09.474
local minimum. But still
essentially I wanna solve for
optimization problem. How do I

00:40:09.474,00:40:15.813
do this. And the first research
came from Burges in 2002 from
Microsoft. Where you know he

00:40:15.813,00:40:21.552
provide a foundation of hey I
wanna solve basically I wanna
look into the problem n equals p

00:40:21.552,00:40:27.992
times q. I am looking for p and
q so that this equation is
true. So I just need to solve

00:40:27.992,00:40:32.897
this I need to write this as
optimization problem. And
basically he rewrote this as N

00:40:32.897,00:40:38.369
minus pq squared and this is
always a positive function. Is
always greater than zero. And

00:40:38.369,00:40:43.374
this is obviously only zero if N
equals pq. And if you write this
way you have what's called a

00:40:45.877,00:40:51.716
QUBO a Quadratic unconstrained
binary optimization problem
which you can happily run on any

00:40:51.716,00:40:56.354
quantannealer that is out
there. And you basically use
binary representation that is

00:40:56.354,00:41:00.992
really just a fancy way up here
of writing P i and Q i but just
the i-th bit it’s either zero or

00:41:00.992,00:41:02.994
one. And you basically now write
this down and it's a very simple
example. My example 15 is 5

00:41:02.994,00:41:04.996
times 3. Now in binary
notation p equals x1,1. The last
bit always has to one because

00:41:04.996,00:41:07.432
the prime number can’t be an
even number. And I just you
know, n minus pq squared I just

00:41:07.432,00:41:13.905
write it through and kind of by
hand say oh this function I need
to minimize now. And I can run

00:41:13.905,00:41:20.545
this against D Wave’s quantum
computer and if I find the
minimI know n equals pq

00:41:20.545,00:41:23.181
because that’s by definition a
positive function. So I can use
quantum’s D’wave’s quantum

00:41:23.181,00:41:26.351
computer they provide a library
as well and you see the link
here you can download it. It’s

00:41:26.351,00:41:29.987
basically same thing you just
call factor P. P is my my
product and I can run this on uh

00:41:29.987,00:41:34.993
D’wave’s quantcomputer. The
problem is if I run this without
any optimization I need n

00:42:00.885,00:42:06.524
squared qubits for this so I
mean the number of qubits that I
need really kind of like grow

00:42:06.524,00:42:11.529
quite heavily and for larger
numbers is not sustainable to
do. But I wanted to show you

00:42:13.531,00:42:18.536
it’s all probability so if I run
this one time I end up with um
my for 15 for the p and q for

00:42:20.605,00:42:26.511
my two prime numbers is one and
seven which is obviously wrong
so I run this once and I didn’t

00:42:26.511,00:42:31.382
really end up in the in the
right spot. But I run this five
times and now I already have 5

00:42:31.382,00:42:36.621
and 3 is already 60 percent um
you know probabilities. And
if I run this fifty times you

00:42:36.621,00:42:42.560
know I know my prime numbers are
already 3 and 5 so I know I need
to run those quantalgorithms

00:42:42.560,00:42:47.899
more and more often to make sure
I end up in the same results. Um
I’m gonna skip over some of

00:42:47.899,00:42:54.338
those things because virtually
all optimizations of now this
base you know of of Burgess’s

00:42:54.338,00:42:59.477
work where he basically looked
into hey my multiplication
matrix that you write out as a

00:42:59.477,00:43:05.516
function to be minimized there
can be lots of optimizations
virtually all of the work that I

00:43:05.516,00:43:12.290
present here now is based on
optimizations of how you do the
multiplications down below here.

00:43:12.290,00:43:16.928
If you’ve ever done
multiplications by hand you know
you start on the right and you

00:43:16.928,00:43:21.799
kind of multiply the lowest
numbers and it carry overs to
the left and virtually all of

00:43:21.799,00:43:28.372
those optimizations go
through this how I can do this
multiplications much easier.

00:43:28.372,00:43:33.377
Dridi and Alghassi did some work
in 2016 where they used some of
these optimizations to remove

00:43:35.379,00:43:41.419
some of the all of the degrees
so they were already able to
factor a number greater than

00:43:41.419,00:43:46.424
200,000 with almost 900 qubits
now D waves qubits on quantum
annealing are not as don’t have

00:43:48.526,00:43:53.998
to be as good as universal
quantcomputer qubit so D wave
announced a system with I

00:43:53.998,00:43:59.003
think around 5,000 qubits for
next year. So 900 qubits is what
was available back then on

00:44:01.939,00:44:07.912
universal quantcomputers. The
biggest prime number is less
than 100 and they these guys in

00:44:07.912,00:44:13.851
2016 could already now factor a
number that was over 200,000.
The big breakthrough was from

00:44:13.851,00:44:18.856
Jiang et al in Indiana in uh
April 2018 and it is really kind
of mindblowing you see the

00:44:21.292,00:44:26.430
next one which was really just
two months after really
around optimization of this

00:44:26.430,00:44:32.603
multiplication map and they have
now raised. They could factor a
number which is greater than

00:44:32.603,00:44:39.076
350,000 with just 94 qubits.
Remember D-wave comes up with
5,000 units quantcomputer

00:44:39.076,00:44:44.081
next week next year. uh
and it's all based on this
optimization problem that we

00:44:46.517,00:44:51.889
solve called factoring and with
optimization to the
multiplication table. And then

00:44:51.889,00:44:57.161
Peng in two thousand in uh
earlier this year really uh
and you can see this uh

00:44:57.161,00:45:01.999
submission was received in July
while the previous submission
was I think submitted in

00:45:01.999,00:45:07.338
April or something it was just
months after. Optimizes even
further and they’ve been able to

00:45:07.338,00:45:11.976
factor a number that was greater
than one million with just 90
qubits. So that’s already 20 bit

00:45:11.976,00:45:17.381
number. So right now when you
look into the problem of hey can
I use a quantcomputer to uh

00:45:17.381,00:45:24.255
factor prime numbers. Universal
computers and Shor’s algorithms
are nowhere compared to uh

00:45:24.255,00:45:30.027
quantannealers. And with
quantannealers I can already
do this with 20 bit

00:45:30.027,00:45:32.029
numbers. So there’s three
things really interesting. So
they they can run this on

00:45:32.029,00:45:34.031
already existing hardware today.
And all of those algorithm
that’s a really big takeaway um

00:45:34.031,00:45:39.036
that you have. To do this I
don’t just have one quantum
problem that I wanna solve. It’s

00:45:48.179,00:45:53.317
always a hybrid model of some
classical compu-computation and
some quantcomputation. I

00:45:53.317,00:45:57.321
really use classic computer what
he’s good at and quantum
computer what a quantcomputer

00:45:57.321,00:46:02.259
is is good at. So my
point is quantannealers are a
thousand fold better right now

00:46:06.530,00:46:11.569
than Shor’s algorithm and
universal quantcomputers. But
because they are too noisy right

00:46:11.569,00:46:18.476
now we are far away from
breaking anything that is in
used in practical terms. Right

00:46:18.476,00:46:24.882
now the biggest number is a 20
bit number. But obviously we
know those two kind of

00:46:24.882,00:46:29.520
like converging curves here. The
algorithms are getting better
and better. At the same time the

00:46:29.520,00:46:34.592
quanthardware gives me more
and more qubits as well. So both
of them will actually have a big

00:46:34.592,00:46:39.397
impact. I can’t just rely on my
predictions saying hey the
number of qubits grow by 15

00:46:39.397,00:46:43.601
percent every year so I’ll be
fine for the next 50 years.
You’re neglecting the

00:46:43.601,00:46:48.506
improvements that the algorithms
will make over the next uh
over the next couple of years

00:46:48.506,00:46:54.578
too. So a couple of myth and
reality. Shor, nobody is gonna
implement Shor on any quantum

00:46:54.578,00:47:00.918
computer whatsoever. Shor
was a theoretical work. There
are practical work you

00:47:00.918,00:47:07.258
know derivations of this work
that will be implemented. at
some point obviously on the on

00:47:07.258,00:47:13.030
the base of Shor’s algorithms
people will break the uh
the RSA encryption. It is a

00:47:13.030,00:47:17.401
matter of time. Now we can argue
whether its ten years, twenty
years, fifty years. But we are

00:47:17.401,00:47:22.673
only arguing about the time. We
are not arguing about arguing
about that it will happen. And

00:47:22.673,00:47:27.378
obviously there’s lots of cases
where this is already has an
impact right now. If I have

00:47:27.378,00:47:33.050
bitcoins right now and my public
key is known. I don’t care
whether it takes me 20 years to

00:47:33.050,00:47:37.888
get the private key to those
to those bitcoins. I figure
in 20 years there’s you know one

00:47:37.888,00:47:42.727
and a half million bitcoins from
Satoshi flying around which is
around 12 billion dollars right

00:47:42.727,00:47:46.997
now. Hey if someone come to me
and say Hi Chris you know can
you bring me quantcomputer.

00:47:46.997,00:47:50.735
Hey it’s really hard it takes me
12 billion dollars you know. Hey
here’s 12 billion dollars right

00:47:50.735,00:47:55.740
there. [laughter] So so
anyway it takes it will be
quite a while but I want to

00:47:58.309,00:48:02.913
[inaudible] off the algorithms
started this talk talking about
how I trust the asymmetric word

00:48:02.913,00:48:07.284
of the RSA word. But there’s
plenty of work and this is uh
kind of you know from this

00:48:07.284,00:48:13.457
Chinese paper in the very end.
That’s the that’s the the
end statement. There’s plenty of

00:48:13.457,00:48:19.397
work on the way right now to use
quantannealers or to look
into symmetric encryption. So

00:48:19.397,00:48:24.468
if you say hey I just use
symmetric encryption I find that
might not be holding up for too

00:48:24.468,00:48:29.874
long and I thank you very much I
am out of time. Thank you very
much for your time. [applause]

00:48:29.874,00:48:34.879
Do we have time for questions?
We don’t have time for
questions. You can find me

00:48:36.981,00:48:40.684
anywhere if you have some
questions. Happy to engage with
you. Thanks so much!

